<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Object-Oriented Programming, Summer 2018 Final
        </title>
    </head>

    <body>
        <h1>
            Object-Oriented Programming, Summer 2018 Final
        </h1>

        <p>
        Name: _______________________________
        </p>

        <p>
        NetID: ______________________________
        </p>

        <ol>
        <li>
                In C++, _____ implement generic programming, while
                _____ implement object-oriented programming.
                <ol type="a" class="nested">
                        <li>
                        templates, classes *
                        </li>
                        <li>
                        include files, .cpp files
                        </li>
                        <li>
                        classes, templates
                        </li>
                        <li>
                        .cpp files, include files
                        </li>
                </ol>
        </li>
        <li>
                Name the four parts of a function.
                <ol type="a" class="nested">
                        <li>
                        pre-process, include, link, compile
                        </li>
                        <li>
                        cout, cin, vector, template
                        </li>
                        <li>
                        return type, name, parameter list, function body *
                        </li>
                </ol>
        </li>
        <li>
                The goal of generic programming is
                <ol type="a" class="nested">
                        <li>
                        to make programs as "plain vanilla" as possible.
                        </li>
                        <li>
                        to allow programmers to write an algorithm once that
                        can then handle all appropriate types. *
                        </li>
                        <li>
                        deal with the generic sort of problems typical users
                        complain about.
                        </li>
                </ol>
        </li>
        <li>
                What does the pre-processor do for your program?
                <ol type="a" class="nested">
                        <li>
                        Turns your C++ code into an object file.
                        </li>
                        <li>
                        Pulls in all of your include files. *
                        </li>
                        <li>
                        Joins separate object files and libraries into a single
                        executable. 
                        </li>
                        <li>
                        Ensures there is a main() function in your program.
                        </li>
                </ol>
        </li>
        <li>
                The C++ compiler... ?
                <ol type="a" class="nested">
                        <li>
                        Turns Python code into C++ code.
                        </li>
                        <li>
                        Pulls together different object files into an
                        executable.
                        </li>
                        <li>
                        Turns source files into object files . *
                        </li>
                </ol>
        </li>

        <li>
                If we write <code>char ch[16]</code> then
                <code>sizeof(ch)</code> on a 64-bit machine will be:
                <ol type="a" class="nested">
                        <li>
                        8 
                        </li>
                        <li>
                        16 *
                        </li>
                        <li>
                        32
                        </li>
                        <li>
                        100
                        </li>
                </ol>
        </li>

        <li>
                If we write <code>char ch[8]; char* p = ch;</code> then
                <code>sizeof(p)</code> on a 64-bit machine will be:
                <ol type="a" class="nested">
                        <li>
                        8 *
                        </li>
                        <li>
                        16
                        </li>
                        <li>
                        32
                        </li>
                        <li>
                        100
                        </li>
                </ol>
        </li>

        <li>
                If we have a pointer in 64-bit Windows, its sizeof()
                most likely is... ?
                <ol type="a" class="nested">
                        <li>
                        the size of whatever it points to
                        </li>
                        <li>
                        8 *
                        </li>
                        <li>
                        4 
                        </li>
                </ol>
        </li>
        <li>
                What does an .h suffix at the end of a file signify in C++?
                <ol type="a" class="nested">
                        <li>
                        It is a heavy file that will take up lots of hard disk
                        space.
                        </li>
                        <li>
                        It is a hard-coded file with lots of constants.
                        </li>
                        <li>
                        It is a healthy file that it would be good to
                        incorporate into your program.
                        </li>
                        <li>
                        It is a header file containing various definitions. *
                        </li>
                </ol>
        </li>
        <li>
                The role of main() in a C++ program is... ?
                <ol type="a" class="nested">
                        <li>
                            To indicate to the compiler what part of the
                            program is most important.
                        </li>
                        <li>
                            To tell the linker where to start execution. *
                        </li>
                        <li>
                            To tell the pre-processor what macros to expand.
                        </li>
                        <li>
                            All of the above.
                        </li>
                </ol>
        </li>
        <li>
                In our first program, what is the purpose of <code>return 0;</code>?
                <ol type="a" class="nested">
                        <li>
                        It signals to the OS that the program failed.
                        </li>
                        <li>
                        It signals to the OS that the program succeeded. *
                        </li>
                        <li>
                        It tells the user that this program did nothing of interest.
                        </li>
                </ol>
        </li>
        <li>
                What does the character '\n' do in an output string?
                <ol type="a" class="nested">
                        <li>
                        terminates all output
                        </li>
                        <li>
                        drops the output down to the next line *
                        </li>
                        <li>
                        adds a nerdline
                        </li>
                        <li>
                        becomes a nexus for further output
                        </li>
                </ol>
        </li>
        <li>
                Generic programming in C++ uses
                <ol type="a" class="nested">
                        <li>
                        classes
                        </li>
                        <li>
                        structures
                        </li>
                        <li>
                        templates *
                        </li>
                </ol>
        </li>
        <li>
                Programming using class hierarchies is called
                <ol type="a" class="nested">
                        <li>
                        procedural programming
                        </li>
                        <li>
                        generic programming
                        </li>
                        <li>
                        object-oriented programming *
                        </li>
                </ol>
        </li>
        <li>
                Resolving what type's method will be called at run-time is characteristic of
                <ol type="a" class="nested">
                        <li>
                        functional programming
                        </li>
                        <li>
                        generic programming
                        </li>
                        <li>
                        object-oriented programming *
                        </li>
                </ol>
        </li>
        <li>
                In C++, a region of memory that holds a value of a certain type is
                called a(n) ... ?
                <ol type="a" class="nested">
                        <li>
                        object *
                        </li>
                        <li>
                        list
                        </li>
                        <li>
                        heap
                        </li>
                        <li>
                        pointer
                        </li>
                </ol>
        </li>
        <li>
                What is a string literal?
                <ol type="a" class="nested">
                        <li>
                        Any hard-coded value
                        </li>
                        <li>
                        An error message to the user.
                        </li>
                        <li>
                        Taking the value of a variable too literally.
                        </li>
                        <li>
                            A value such as "hello" or "good luck".
                        </li>

                </ol>
        </li>
        <li>
                What is the difference between 'a' and "a" in C++?
                <ol type="a" class="nested">
                        <li>
                        The first is a character literal, the second is a
                        string literal.
                        </li>
                        <li>
                        They are the same: you can use the interchangeably.
                        </li>
                        <li>
                        The first is a string literal, the second is a
                        character literal.
                        </li>
                </ol>
        </li>
        <li>
                Which of the following is a legal variable name in C++?
                <ol type="a" class="nested">
                        <li>
                        isdigit()
                        </li>
                        <li>
                        is_this_ok *
                        </li>
                        <li>
                        number!
                        </li>
                        <li>
                        3street4
                        </li>
                </ol>
        </li>
        <li>
                We use a declaration of a function when we...
                <ol type="a" class="nested">
                        <li>
                        we want to write the function body, without giving the
                        return type or the types of the parameters.
                        </li>
                        <li>
                        just want to state its return type and the types of its
                        parameters, but not write the function body. *
                        </li>
                        <li>
                        just want to declare that the function exists.
                        </li>
                </ol>
        </li>
        
        <li>
                A member function of a class can ..
                <ol type="a" class="nested">
                        <li>
                        Access subclass members
                        </li>
                        <li>
                        Access all the members of the class *
                        </li>
                        <li>
                        Access only the private members of the class
                        </li>
                        <li>
                        Access only public members of the class
                        </li>
                </ol>
        </li>
        <li>
                Which of the following is not necessary for constructors?
                <ol type="a" class="nested">
                        <li>
                        It must contain a definition body *
                        </li>
                        <li>
                        Its name must be same as that of class
                        </li>
                        <li>
                        It must not have any return type
                        </li>
                </ol>
        </li>
        <li>
                Which of the following operators cannot be overloaded?
                <ol type="a" class="nested">
                        <li>
                        . (Dot operator)
                        </li>
                        <li>
                        ?: (Ternary Operator)
                        </li>
                        <li>
                        :: (Scope resolution operator)
                        </li>
                        <li>
                        All of the above *
                        </li>
                </ol>
        </li>

        <li>
                For a small set of constant values for something like
                "boroughs of New York City," a good construct  to use would be
                a(n)
                <ol type="a" class="nested">
                        <li>
                        conditional type
                        </li>
                        <li>
                        compound type
                        </li>
                        <li>
                        template
                        </li>
                        <li>
                        enumeration *
                        </li>
                </ol>
        </li>

        <li>
                In C++, const qualifier can be applied to : 1. Member functions
                of a class; 2. Function arguments; 3. to a class data member
                which is declared as static; 4. Reference variables
                <ol type="a" class="nested">
                        <li>
                        only 1, 3 and 4
                        </li>
                        <li>
                        only 1, 2 and 3
                        </li>
                        <li>
                        only 1,2 and 4
                        </li>
                        <li>
                        all *
                        </li>
                </ol>
        </li>
        <li>
                An <code>istream</code> fundamentally...
                <ol type="a" class="nested">
                        <li>
                        hides all user input from the programmer
                        </li>
                        <li>
                        hides the details of input devices from the programmer
                        *
                        </li>
                        <li>
                        hides what data types are being input from the
                        programmer
                        </li>
                </ol>
        </li>
        <li>
                A file is fundamentally...
                <ol type="a" class="nested">
                        <li>
                        an icon inside a folder
                        </li>
                        <li>
                        a list of records
                        </li>
                        <li>
                        a sequence of bytes stored on some media *
                        </li>
                </ol>
        </li>

        <li>
                Which of the following is a legal variable name that,
                nevertheless, you should not use?
                <ol type="a" class="nested">
                        <li>
                        CaSe *
                        </li>
                        <li>
                        i
                        </li>
                        <li>
                        rval
                        </li>
                        <li>
                        all of the above answers 
                        </li>
                </ol>
        </li>
        <li>
                Which of the following is a <b>safe</b> type conversion?
                <ol type="a" class="nested">
                        <li>
                        double to int
                        </li>
                        <li>
                        int to char
                        </li>
                        <li>
                        int to bool
                        </li>
                        <li>
                        none of these are safe *
                        </li>
                </ol>
        </li>
        <li>
                If we are trying to represent pi as a double... ?
                <ol type="a" class="nested">
                        <li>
                        our representation will only approximate the actual
                        value *
                        </li>
                        <li>
                        it will produce a run-time error.
                        </li>
                        <li>
                        that value is out of range, since the digits continue
                        forever
                        </li>
                        <li>
                            we can represent it exactly
                        </li>

                </ol>
        </li>
        <li>
                Which of these operators can be used on integers but not
                floating point numbers?
                <ol type="a" class="nested">
                        <li>
                        /
                        </li>
                        <li>
                        +
                        </li>
                        <li>
                        % *
                        </li>
                        <li>
                        -
                        </li>
                        <li>
                        *=
                        </li>
                </ol>
        </li>
        <li>
                Which of the following operators requires an lvalue?
                <ol type="a" class="nested">
                        <li>
                        []
                        </li>
                        <li>
                            -&gt;
                        </li>
                        <li>
                        /
                        </li>
                        <li>
                        %= *
                        </li>
                </ol>
        </li>
        <li>
                Which of the following operations can be used on an int but not a string?
                <ol type="a" class="nested">
                        <li>
                        +
                        </li>
                        <li>
                        % *
                        </li>
                        <li>
                        +=
                        </li>
                </ol>
        </li>
        <li>
                The middle part of the for loop statement...
                <ol type="a" class="nested">
                        <li>
                        initializes the loop variable.
                        </li>
                        <li>
                        determines when the loop terminates. *
                        </li>
                        <li>
                        is done each time around the loop.
                        </li>
                </ol>
        </li>
        <li>
                We should prefer a switch statement to if and else statements when...
                <ol type="a" class="nested">
                        <li>
                        we only have two options to consider.
                        </li>
                        <li>
                        there are many cases to consider. *
                        </li>
                        <li>
                        the conditions for the branches are string comparisons.
                        </li>
                </ol>
        </li>
        <li>
                When writing an assignment operator overload, why do we return *this?
                <ol type="a" class="nested">
                        <li>
                        Because in C++, assignment returns a value. *
                        </li>
                        <li>
                        Because we want to draw attention to the object that was assigned to.
                        </li>
                        <li>
                        Because we need to tell the compiler what object we are assigning to.
                        </li>
                </ol>
        </li>
        <li>
                Why don't we add new memory to our vector's storage on every
                call to <code>push_back()</code>?
                <ol type="a" class="nested">
                        <li>
                        Because the system won't let us make that many calls to <code>malloc</code>.
                        </li>
                        <li>
                        Because it costs a lot of CPU cycles to do that. *
                        </li>
                        <li>
                        Because we are lazy, and don't want to write that much code.
                        </li>
                </ol>
        </li>
        <li>
                If we have a vector named v, then v[2] will access the ___th
                element of that vector?
                <ol type="a" class="nested">
                        <li>
                        4
                        </li>
                        <li>
                        3 *
                        </li>
                        <li>
                        2
                        </li>
                        <li>
                        can't say
                        </li>
                </ol>
        </li>
        <li>
                If a function is declared as double f(char* c); that means...
                <ol type="a" class="nested">
                        <li>
                        it doubles the value of its argument c and then
                        converts it to a char.
                        </li>
                        <li>
                        the name of the function is double and it applies the
                        operator f to a character.
                        </li>
                        <li>
                        it returns a double and accepts a pointer to a
                        character as an argument. *
                        </li>
                        <li>
                        it returns a double and accepts a character as an argument.
                        </li>
                </ol>
        </li>
        <li>
                The four major types of errors are...
                <ol type="a" class="nested">
                        <li>
                        header errors, variable errors, function errors and class errors
                        </li>
                        <li>
                        compile-time, link-time, run-time, and logical *
                        </li>
                        <li>
                        object errors, inheritance errors, template errors and polymorphism errors
                        </li>
                </ol>
        </li>
        <li>
                A linker error would occur when...
                <ol type="a" class="nested">
                        <li>
                        A linked list is specified incorrectly.
                        </li>
                        <li>
                        A function with the same signature is found to be
                        defined twice. *
                        </li>
                        <li>
                        A link between one class and another is missing.
                        </li>
                </ol>
        </li>
        <li>
                An example of a run-time error is when...
                <ol type="a" class="nested">
                        <li>
                        you use a template to call a function not in the
                        template.
                        </li>
                        <li>
                        you left off the semi-colon at the end of a line of
                        code.
                        </li>
                        <li>
                        you meant to add tax to the sales price but you
                        subtracted it instead.
                        </li>
                        <li>
                        your program deallocates memory twice. *
                        </li>
                </ol>
        </li>
        <li>
                An example of a logic error is when...
                <ol type="a" class="nested">
                        <li>
                        you use a type for a template that does not support the
                        semantics of the template. *
                        </li>
                        <li>
                        you send the wrong type of argument to a function.
                        </li>
                        <li>
                        your program accesses memory that is outside its
                        allotted area.
                        </li>
                        <li>
                        you forget the semi-colon at the end of a line of code.
                        </li>
                </ol>
        </li>
        <li>
                One reason why throwing an exception is better than returning
                an error value is...
                <ol type="a" class="nested">
                    <li>
                        throwing an exception is more up-to-date.
                    </li>
                        <li>
                        an exception can be caught at various places in the
                        program. *
                        </li>

                        <li>
                        throwing an exception makes the code that produced the
                        error also handle it.
                        </li>
                        <li>
                        throwing exceptions is a more modern style.
                        </li>
                </ol>
        </li>
        
        <li>
                Most large programs...
                <ol type="a" class="nested">
                        <li>
                        can be fully de-bugged in a couple of days.
                        </li>
                        <li>
                        will likely be bug-free from the start.
                        </li>
                        <li>
                        are read more often than re-written. *
                        </li>
                </ol>
        </li>
        <li>
                Which of the following does not cause a syntax error to be
                reported by the C++ compiler?
                <ol type="a" class="nested">
                        <li>
                        Missing ; at the end of a statement
                        </li>
                        <li>
                        Missing */ in a comment
                        </li>
                        <li>
                        Mismatched []
                        </li>
                        <li>
                        Using a pointer to access unallocated memory *
                        </li>
                </ol>
        </li>
        <li>
            If we want a safer version of a pointer we can use... ?
                <ol type="a" class="nested">
                        <li>
                        de-referencing a pointer
                        </li>
                        <li>
                            a reference *
                        </li>
                        <li>
                        a pointer to a pointer
                        </li>
                        <li>
                        all of the above
                        </li>
                </ol>
        </li>
        <li>
                Which of the following is not a syntax error?
                <ol type="a" class="nested">
                        <li>
                        std::cout &lt;&lt; "Hello world! ';
                        </li>
                        <li>
                        std::cout &lt;&lt; 'Hello world! ';
                        </li>
                        <li>
                        std::cout &lt;&lt; "Hello world! "; *
                        </li>
                </ol>
        </li>
        <li>
                Run-time errors are ..
                <ol type="a" class="nested">
                        <li>
                        the errors which are traced by the compiler during
                        compilation, due to wrong grammar for the language used
                        in the program
                        </li>
                        <li>
                        the errors encountered during execution of the program,
                        due to unexpected input or output *
                        </li>
                        <li>
                        the errors encountered when the program does not give
                        the desired output
                        </li>
                </ol>
        </li>
        <li>
                A downside of range checking the indexes used on a vector 
                is that 
                <ol type="a" class="nested">
                        <li>
                        it will take some time and slow the code *
                        </li>
                        <li>
                        sometimes an index will be out of range and produce an
                        error
                        </li>
                        <li>
                        it stifles programmer creativity
                        </li>
                        <li>
                        none of the above
                        </li>
                </ol>
        </li>
 
        <li>
                What are the three main phases of software development?
                <ol type="a" class="nested">
                        <li>
                        analysis, design and implementation *
                        </li>
                        <li>
                        classes, functions, and variables
                        </li>
                        <li>
                        hacking, coding, and testing
                        </li>
                </ol>
        </li>
 
        <li>
                We typically break an interpreter into two phases called
                <ol type="a" class="nested">
                        <li>
                        expressing and optimizing
                        </li>
                        <li>
                        tokenization and compiling
                        </li>
                        <li>
                        tokenization and parsing *
                        </li>
                        <li>
                        parsing and expressing
                        </li>
                </ol>
        </li>
        <li>
                In the switch() in the expression function, why is the default
                to "put back" the token?
                <ol type="a" class="nested">
                        <li>
                        That token will probably be a + or - and can be dealt
                        with by the next call to expression.
                        </li>
                        <li>
                        That token will be meaningless, and we want to throw it
                        away.
                        </li>
                        <li>
                        If we hit the default case, we have read one token too
                        many. *
                        </li>
                </ol>
        </li>
        <li>
                A primary purpose of classes is to
                <ol type="a" class="nested">
                        <li>
                        make our program more classy
                        </li>
                        <li>
                        organize our code better *
                        </li>
                        <li>
                        make our program more object-oriented
                        </li>
                </ol>
        </li>
        <li>
                Classes include
                <ol type="a" class="nested">
                        <li>
                        header files and libraries
                        </li>
                        <li>
                        methods and header files
                        </li>
                        <li>
                        variables and methods *
                        </li>
                </ol>
        </li>

        <li>
                If we have a constructor that takes a single argument of
                another type, like:
                <br />
                Complex::Complex(double d);
                <br />
                that can be used for:
                <ol type="a" class="nested">
                        <li>
                        enumerating a new type
                        </li>
                        <li>
                        creating a template
                        </li>
                        <li>
                        implicit type conversions between the types *
                        </li>
                </ol>
        </li>
        <li>
                What is a token?
                <ol type="a" class="nested">
                        <li>
                        a variable
                        </li>
                        <li>
                        Smallest element of a program meaningful to the compiler *
                        </li>
                        <li>
                        a constant
                        </li>
                        <li>
                        Smallest element of a program
                        </li>
                </ol>
        </li>
        
        <li>
                Why did we introduce a const name like 'number' into our
                program?
                <ol type="a" class="nested">
                        <li>
                        to make the program more maintainable *
                        </li>
                        <li>
                        it saves storage since the const takes up less space
                        than the char
                        </li>
                        <li>
                        the compiler demands this or it will produce an error
                        </li>
                        <li>
                        all of the above
                        </li>
                </ol>
        </li>

        <li>
            When we want to verify a class we wrote works before using it in
            a larger program, we write a... ?
                <ol type="a" class="nested">
                        <li>
                        sub-class
                        </li>
                        <li>
                        template
                        </li>
                        <li>
                        test harness *
                        </li>
                </ol>
        </li>

        <li>
                What is wrong with commenting x = a + b; with // add a and b
                and put value in x
                <ol type="a" class="nested">
                        <li>
                        It does not describe the code  correctly.
                        </li>
                        <li>
                        Variable names should never occur in comments.
                        </li>
                        <li>
                        It will confuse the compiler.
                        </li>
                        <li>
                        It only says what the code already clearly says. *
                        </li>
                </ol>
        </li>
        <li>
                What is the purpose of commenting in a program?
                <ol type="a" class="nested">
                        <li>
                        It is necessary for the compilation of the code
                        </li>
                        <li>
                        It is something not to be bothered about
                        </li>
                        <li>
                        To make the program more readable and easy to
                        understand *
                        </li>
                        <li>
                        None of the above
                        </li>
                </ol>
        </li>
        <li>
                What is the use of symbolic constant?
                <ol type="a" class="nested">
                        <li>
                        Nothing much useful in it
                        </li>
                        <li>
                        The code is less error prone, easier to change and
                        understand *
                        </li>
                        <li>
                        Symbolic constants help the code to run faster
                        </li>
                        <li>
                        None of the above
                        </li>
                </ol>
        </li>
        <li>
                What is the difference between a function declaration and a
                function definition?
                <ol type="a" class="nested">
                        <li>
                        the declaration includes the function body, while the
                        definition just gives the function's return and
                        parameter types
                        </li>
                        <li>
                        the declaration just gives the function's return and
                        parameter types, while the definition includes the
                        function body *
                        </li>
                </ol>
        </li>
        <li>
                What are header files used for?
                <ol type="a" class="nested">
                        <li>
                        To head off disaster.
                        </li>
                        <li>
                        To put a nice header at the top of your code if you
                        print it.
                        </li>
                        <li>
                        To provide declarations needed for multiple source code
                        files. *
                        </li>
                </ol>
        </li>
        <li>
                We should use "pass by constant reference" when... ?
                <ol type="a" class="nested">
                        <li>
                        the object being passed is too large to pass by value,
                        but we don't want to change its value inside our
                        function *
                        </li>
                        <li>
                        it makes the structure of the code clearer to a human
                        reader 
                        </li>
                        <li>
                        we want to refer to the object constantly, in many
                        lines of our code
                        </li>
                </ol>
        </li>
        <li>
                We should use "pass by reference" when... ?
                <ol type="a" class="nested">
                        <li>
                        the type we are passing is very small
                        </li>
                        <li>
                        we only want to refer to an argument to our function,
                        not change it
                        </li>
                        <li>
                        we need to change the value of an argument to our
                        function *
                        </li>
                </ol>
        </li>
        <li>
                We use a move assignment when we
                <ol type="a" class="nested">
                        <li>
                        do not wish to copy all storage from
                        the object assigned from and the object assigned to *
                        </li>
                        <li>
                        we wish to move values from one object to another
                        </li>
                        <li>
                        the values being copied are highly mobile
                        </li>
                        <li>
                            all of the above
                        </li>

                </ol>
        </li>
        <li>
                If we write 
                <br>
                char* cptr = &amp;c[10];
                <br />
                we get:
                <ol type="a" class="nested">
                        <li>
                        a pointer to the 11th element of the array c *
                        </li>
                        <li>
                        a pointer to the 10th element of the array c 
                        </li>
                        <li>
                        a pointer to an array of 10 elements
                        </li>
                        <li>
                        a pointer to an array of 11 elements
                        </li>
                </ol>
        </li>
        <li>
                Passing by reference means …
                <ol type="a" class="nested">
                        <li>
                        parameter will be the same as the callers' passed argument (not the value, but the identity - the variable itself) *
                        </li>
                        <li>
                        the called function's parameter will be a copy of the callers' passed argument
                        </li>
                </ol>
        </li>
        <li>
                Passing by value means …
                <ol type="a" class="nested">
                        <li>
                        parameter will be the same as the callers' passed argument (not the value, but the identity - the variable itself)
                        </li>
                        <li>
                        the called function's parameter will be a copy of the callers' passed argument *
                        </li>
                </ol>
        </li>
        <li>
                Function definition consists of …
                <ol type="a" class="nested">
                        <li>
                        function name and body
                        </li>
                        <li>
                        function body and return type
                        </li>
                        <li>
                        function name, parameters, return value type, and body *
                        </li>
                </ol>
        </li>
        <li>
                What is the return type here: int myMethod(int count, double value) {    return 4;	}
                <ol type="a" class="nested">
                        <li>
                        MyMethod
                        </li>
                        <li>
                        int *
                        </li>
                        <li>
                        4
                        </li>
                        <li>
                        double
                        </li>
                        <li>
                        count
                        </li>
                </ol>
        </li>
        <li>
            A local variable is one that is... ?
                <ol type="a" class="nested">
                        <li>
                        declared to be part of a class
                        </li>
                        <li>
                        declared in a header file
                        </li>
                        <li>
                        declared in a function *
                        </li>
                </ol>
        </li>

        <li>
                What is the scope of a variable declared in a user-defined
                function?
                <ol type="a" class="nested">
                        <li>
                        the whole program
                        </li>
                        <li>
                        the main function
                        </li>
                        <li>
                        always and only the entire function
                        </li>
                        <li>
                        none of the above *
                        </li>
                </ol>
        </li>

        <li>
            A copy constructor is use... ?
                <ol type="a" class="nested">
                        <li>
                            to copy the code of another constructor
                        </li>
                        <li>
                            to convert between basic C++ types
                        </li>
                        <li>
                            to construct an object of type A given
                            another object of type A *
                        </li>
                        <li>
                            to construct an object of type A given
                            an object of type B
                        </li>
                </ol>
        </li>

        <li>
                What are the two parts of a class?
                <ol type="a" class="nested">
                        <li>
                        variants and constants
                        </li>
                        <li>
                        interface and implementation *
                        </li>
                        <li>
                        local and global
                        </li>
                        <li>
                        interference and instantiation
                        </li>
                </ol>
        </li>
        <li>
                Which of the following is a class invariant for
                <code>Date</code>?
                <ol type="a" class="nested">
                        <li>
                        month should be defined as an <code>int</code>
                        </li>
                        <li>
                        printed dates should never take up more than one column
                        in a spreadsheet
                        </li>
                        <li>
                        the year cannot be a leap year
                        </li>
                        <li>
                        we must always have a day less than 31 *
                        </li>
                </ol>
        </li>
        <li>
                When should the body of a function (its definition) be put in
                the class definition?
                <ol type="a" class="nested">
                        <li>
                        when we want the compiler to inline the function *
                        </li>
                        <li>
                        when the function returns a built-in type
                        </li>
                        <li>
                        when the function is over 10 lines long
                        </li>
                        <li>
                        when the function returns a user-defined type
                        </li>
                </ol>
        </li>
        <li>
                What would be a reasonable way to overload the *
                operator?
                <ol type="a" class="nested">
                        <li>
                        to multiply two matrices *
                        </li>
                        <li>
                        to sort a list of strings
                        </li>
                        <li>
                        to access a website and add all of its pages to your
                        site
                        </li>
                </ol>
        </li>
        <li>
                What does adding <code>const</code> to a member function do?
                <ol type="a" class="nested">
                        <li>
                        promises that the function will not change the object *
                        </li>
                        <li>
                        says the function is a constructor
                        </li>
                        <li>
                        asserts that the function will constantly return the same value for the same input
                        </li>
                </ol>
        </li>
        <li>
                A class can hold the following
                <ol type="a" class="nested">
                        <li>
                        data
                        </li>
                        <li>
                        functions
                        </li>
                        <li>
                        both data &amp; functions *
                        </li>
                        <li>
                        none of the mentioned
                        </li>
                </ol>
        </li>
        <li>
                How do we specify a method of a class when we are defining it
                externally?
                <ol type="a" class="nested">
                        <li>
                        ClassName~method()
                        </li>
                        <li>
                        ClassName::method() *
                        </li>
                        <li>
                            ClassName-&gt;method() *
                        </li>
                        <li>
                        none of the above
                        </li>
                </ol>
        </li>
        <li>
                Which of the following is an access specifier?
                <ol type="a" class="nested">
                        <li>
                        protected
                        </li>
                        <li>
                        private
                        </li>
                        <li>
                        public
                        </li>
                        <li>
                        all of the above *
                        </li>
                </ol>
        </li>

        <li>
                Why is input usually harder than output?
                <ol type="a" class="nested">
                        <li>
                        <code>istream</code> is a trickier class than
                        <code>ostream</code>
                        </li>
                        <li>
                        input devices require more assembly language code than
                        output devices
                        </li>
                        <li>
                        The user might input almost anything! *
                        </li>
                </ol>
        </li>
        <li>
                What are the four steps for reading a file?
                <ol type="a" class="nested">
                        <li>
                        delete the file, read from stdin, write the results
                        there, and close stdin
                        </li>
                        <li>
                        know its name, open it, read in the contents, and close
                        it *
                        </li>
                        <li>
                        generate the file, write out its contents, close it,
                        and verify a good result
                        </li>
                </ol>
        </li>
  
        <li>
                Unformatted input functions are handled by
                <ol type="a" class="nested">
                        <li>
                        instream
                        </li>
                        <li>
                        bufstream
                        </li>
                        <li>
                        ostream
                        </li>
                        <li>
                        istream *
                        </li>
                </ol>
        </li>

        <li>
                A class that defines cout, cerr and clog objects and stream insertion operator is
                <ol type="a" class="nested">
                        <li>
                        istream
                        </li>
                        <li>
                        fstream
                        </li>
                        <li>
                        ostream *
                        </li>
                        <li>
                        kstream
                        </li>
                </ol>
        </li>
       
        <li>
                Which of the following is not a basic floating-point output
                manipulator?
                <ol type="a" class="nested">
                        <li>
                        setprecision
                        </li>
                        <li>
                        explicit *
                        </li>
                        <li>
                        scientific
                        </li>
                        <li>
                        fixed
                        </li>
                </ol>
        </li>
        <li>
                What does isalpha(c) return?
                <ol type="a" class="nested">
                        <li>
                        true if is c a letter; false otherwise *
                        </li>
                        <li>
                        the character equivalent of some ASCII code
                        </li>
                        <li>
                        is c printable; false otherwise
                        </li>
                        <li>
                        the ASCII code for a character
                        </li>
                </ol>
        </li>
        <li>
                Your class needs a destructor if...
                <ol type="a" class="nested">
                        <li>
                        it contains a vector
                        </li>
                        <li>
                        it acquires resources while in use *
                        </li>
                        <li>
                        it is a type of stack
                        </li>
                        <li>
                        it has a virtual member function
                        </li>
                </ol>
        </li>
        <li>
            A pointer that is immutable and automatically de-referenced 
            is a 
                <ol type="a" class="nested">
                        <li>
                        a pointer to a pointer
                        </li>
                        <li>
                        a reference *
                        </li>
                        <li>
                        an array 
                        </li>
                </ol>
        </li>
        <li>
                <code>x = d[-3];</code> would be valid C++ when d is 
                <ol type="a" class="nested">
                        <li>
                        a vector
                        </li>
                        <li>
                        a double
                        </li>
                        <li>
                        an array *
                        </li>
                </ol>
        </li>
        <li>
                A good use of shallow copying would be when
                <ol type="a" class="nested">
                        <li>
                        we have a very large object to copy *
                        </li>
                        <li>
                        we just need to scoop out the top few values from an object
                        </li>
                        <li>
                        we don't really care if all the field values are the same
                        </li>
                </ol>
        </li>
        <li>
                A good use of deep copying would be when
                <ol type="a" class="nested">
                        <li>
                        we need to make sure the values in one object change when values in the other do
                        </li>
                        <li>
                        we need to make sure each objects uses separate memory *
                        </li>
                        <li>
                        we need to save memory
                        </li>
                </ol>
        </li>
        <li>
                We want a default constructor when
                <ol type="a" class="nested">
                        <li>
                        we can establish meaningful invariants using default values *
                        </li>
                        <li>
                        we really don't know what should initialize a class
                        </li>
                        <li>
                        we want to eliminate the faults (defaults) from our classes
                        </li>
                </ol>
        </li>
        <li>
                We need a destructor when our class
                <ol type="a" class="nested">
                        <li>
                        has many members
                        </li>
                        <li>
                        has default values
                        </li>
                        <li>
                        has no copy constructor
                        </li>
                        <li>
                        acquires resources *
                        </li>
                </ol>
        </li>

        <li>
                If we write <code>char* student = "Daniel";</code> that will
                create a character array of ___ bytes:
                <ol type="a" class="nested">
                        <li>
                        6
                        </li>
                        <li>
                        depends on the compiler
                        </li>
                        <li>
                        8
                        </li>
                        <li>
                        7 *
                        </li>
                </ol>
        </li>

        <li>
                Among common pointer problems are:
                <ol type="a" class="nested">
                        <li>
                        access off the end of an array
                        </li>
                        <li>
                        access through the null pointer
                        </li>
                        <li>
                        access to a deallocated object
                        </li>
                        <li>
                        all of the above *
                        </li>
                </ol>
        </li>

        <li>
                In C++, we can give our own classes array-style access by:
                <ol type="a" class="nested">
                        <li>
                        overloading the [] operator *
                        </li>
                        <li>
                        all answers are correct
                        </li>
                        <li>
                        writing <code>get()</code> and <code>set()</code> functions
                        </li>
                        <li>
                        using pointers to pointers
                        </li>
                </ol>
        </li>
        <li>
                Generic programming means
                <ol type="a" class="nested">
                        <li>
                        programming according to generic standards.
                        </li>
                        <li>
                        writing code that works with a variety of types
                        presented as arguments. *
                        </li>
                        <li>
                        writing just standard variety code with nothing
                        outstanding about it.
                        </li>
                </ol>
        </li>
        </ol>

        <h3>
            Problem
        </h3>

        <p>
        8 points
        <br>
        Consider the following code, part of a vector class
        where sz holds the number of slots used in the vector's storage, and
        space records the vectors current maximum number of items that can be
        stored:
        </p>
        
        <p>
        <code>
            <pre>

        void vector::reserve(int newalloc)
        {
            if(newalloc &lt;= space) return;
            double* p = new double[newalloc];
            for(int i = 0; i &lt; sz; ++i) p[i] = elem[i];  // copy elements
            delete[] elem;  // deallocate old space
            elem = p;
            space = newalloc;
        }

        void vector::resize(int newsize)
        {
            reserve(newsize);
            for(int i = sz; i &lt; newsize; ++i) elem[i] = 0;
            sz = newsize;
        }
            </pre>
        </code>
        </p>

        <p>
        <code>resize()</code> needs to handle four possibilities:
        </p>

        <ul>
            <li>
                The new size is larger than the old allocation.
            </li>

            <li>
                The new size is larger than the old size,
                but smaller than or equal to the old
                allocation.
            </li>

            <li>
                The new size is equal to the old size.
            </li>

            <li>
                The new size is smaller than the old size.
            </li>
        </ul>

        <p>
            Please reason about the construction of reserve() and resize()
            to argue that resize() will (or won't!) handle these four 
            possibilities correctly.
        </p>

    </body>
</html>

<!DOCTYPE html>
<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <link rel="stylesheet" href="style.css">

        <!-- jQuery CDN -->
         <script src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
         <!-- Bootstrap Js CDN -->
         <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

         <script type="text/javascript">
             var status = 'on';
             $(document).ready(function () {
                 $('#sidebarCollapse').on('click', function () {
                     $('#sidebar').toggleClass('active');
                     if (status == 'on') {
                         $('#sidebarText').text("Expand Side Nav");
                         status = 'off';
                     } else {
                         $('#sidebarText').text("Collapse Side Nav");
                         status = 'on';
                     }
                 });
             });
         </script>
        <title>
            10. Input and Output Streams
        </title>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114841175-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-114841175-1');
</script>
    </head>

    <body>
        <div class="wrapper">
<!-- Sidebar Holder -->
<nav id="sidebar">
        <div id="sidebarCollapse">
        <div class="sidebar-header">
            <h1>
            Object-Oriented Programming
            </h1>
            <strong>OOP</strong>
        </div>
    </div>
    <ul class="list-unstyled components">
        <li>
        <a href="index.html">
        <i class="glyphicon glyphicon-home"></i>
        Home
        </a>
        </li>
        <li>
        <a href="#Submenu0" data-toggle="collapse" aria-expanded="false">
        <i class="glyphicon glyphicon-list"></i>
        Topics
        </a>
        </li>
        <ul class="collapse list-unstyled" id="Submenu0">
            <li>
            <a href="#Submenu1" data-toggle="collapse" aria-expanded="false">
            Part I: The Basics
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu1">
                <li>
                <a href="hello.html">
                2. Hello, World!
                </a>
                </li>
                <li>
                <a href="otv.html">
                3. Objects, Types, and Values
                </a>
                </li>
                <li>
                <a href="computation.html">
                4. Computation
                </a>
                </li>
                <li>
                <a href="errors.html">
                5. Errors
                </a>
                </li>
                <li>
                <a href="writing.html">
                6. Writing a Program
                </a>
                </li>
                <li>
                <a href="completing.html">
                7. Completing a Program
                </a>
                </li>
                <li>
                <a href="functions.html">
                8. Technicalities: Functions, etc.
                </a>
                </li>
                <li>
                <a href="classes.html">
                9. Technicalities: Classes, etc.
                </a>
                </li>
            </ul>
            <li>
            <a href="#Submenu2" data-toggle="collapse" aria-expanded="false">
            Part II: Input and Output
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu2">
                <li>
                <a href="iostreams.html">
                10. Input and Output Streams
                </a>
                </li>
                <li>
                <a href="customizingio.html">
                11. Customizing Input and Output
                </a>
                </li>
                <li>
                <a href="display_model.html">
                12. A Display Model
                </a>
                </li>
                <li>
                <a href="graphics_classes.html">
                13. Graphics Classes
                </a>
                </li>
                <li>
                <a href="class_design.html">
                14. Graphics Class Design
                </a>
                </li>
                <li>
                <a href="graphing_funcs.html">
                15. Graphing Functions and Data
                </a>
                </li>
                <li>
                <a href="gui.html">
                16. Graphical User Interfaces
                </a>
                </li>
            </ul>
            <li>
            <a href="#Submenu3" data-toggle="collapse" aria-expanded="false">
            Part III: Data and Algorithms
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu3">
                <li>
                <a href="vector_free.html">
                17. Vector and Free Store
                </a>
                </li>
                <li>
                <a href="vector_array.html">
                18. Vectors and Arrays
                </a>
                </li>
                <li>
                <a href="vector_templ.html">
                19. Vector, Templates, and Exceptions
                </a>
                </li>
                <li>
                <a href="containers.html">
                20. Containers and Iterators
                </a>
                </li>
                <li>
                <a href="algorithms.html">
                21. Algorithms and Maps
                </a>
                </li>
            </ul>
            <li>
            <a href="#Submenu4" data-toggle="collapse" aria-expanded="false">
            Part IV Broadening the View
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu4">
                <li>
                <a href="history.html">
                22. Ideals and History
                </a>
                </li>
                <li>
                <a href="text.html">
                23. Text Manipulation
                </a>
                </li>
                <li>
                <a href="numerics.html">
                24. Numerics
                </a>
                </li>
                <li>
                <a href="embedded.html">
                25. Embedded Systems Programming
                </a>
                </li>
                <li>
                <a href="testing.html">
                26. Testing
                </a>
                </li>
                <li>
                <a href="C.html">
                27. The C Programming Language
                </a>
                </li>
            </ul>
        </ul>
        <li>
        <a href="#Submenu5" data-toggle="collapse" aria-expanded="false">
        <i class="glyphicon glyphicon-blackboard"></i>
        Other Materials
        </a>
        </li>
        <ul class="collapse list-unstyled" id="Submenu5">
            <li>
            <a href="syllabi/SyllabusSu2018.html">
            <i class="glyphicon glyphicon-tasks"></i>
            Course Syllabus
            </a>
            </li>
            <li>
            <a href="https://github.com/gcallah/OOP/tree/03c8d77c5ee5faae253d8a8e989aa347af0c3c45/code">
            <i class="glyphicon glyphicon-list-alt"></i>
            Source Code
            </a>
            </li>
            <li>
            <a href="tests/midterm_key.html">
            <i class="glyphicon glyphicon-pencil"></i>
            Midterm
            </a>
            </li>
            <li>
            <a href="http://www.stroustrup.com/programming.html">
            <i class="glyphicon glyphicon-book"></i>
            Our textbook's website
            </a>
            </li>
            <li>
            <a href="C++tips.html">
            <i class="glyphicon glyphicon-hand-right"></i>
            C++ Tips
            </a>
            </li>
            <li>
            <a href="https://gcallah.github.io/utils/unix_guide.html">
            <i class="glyphicon glyphicon-hand-right"></i>
            Guide to UNIX
            </a>
            </li>
        </ul>
        <li>
        <a href="about.html">
        <i class="glyphicon glyphicon-info-sign"></i>
        About
        </a>
        </li>
    </ul>
</nav>
            <div id="content">
                <h1>
                    10. Input and Output Streams
                </h1>
                <details>
                    <summary class="sum1">
                    10.1 Input and output
                    </summary>
                    <figure>
                        <img src="graphics/Chap10Diag1.png" width="50%">
                    </figure>
                    <p>
                      We need to get data into our program to do
                      interesting computations and we need to get
                      the results out again.
                      <br><br>
                      In C++ Programming, I/O occurs in streams,
                      which are sequences of bytes handled by the
                      input/output library.
                      <br><br>
                      An <i>input operation</i> is when bytes flow from a
                      device like a keyboard, a disk drive, or a
                      network connection etc. to main memory while an
                      <i>output operation</i> is when bytes flow
                      from main memory to a device like a display screen,
                      a printer, a disk drive, or a network connection, etc.
                      <br><br>
                      In this chapter, we’ll learn how to handle I/O
                      consisting of streams using the C++ standard library.
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    10.2 The I/O stream model
                    </summary>
                    <p>
                      <code>istream</code>:
                      <br>
                      <ul>
                        <li>
                          The type <code>istream </code> deals with streams of
                          input.
                        </li>
                        <li>
                          It turns character sequences into values
                          of various types.
                        </li>
                        <li>
                          It gets those characters from somewhere
                          (such as a console, a file, the main memory,
                          or another computer).
                        </li>
                        <li>
                          <code>istream</code> is quite
                          visible when used from keyboard;
                          what you type is left in the buffer until you
                          hit Enter (return/newline),
                          and you can use the erase (Backspace)
                          key “to change your mind” (until you hit Enter).
                        </li>
                      </ul>
                    </p>
                    <p>
                      <span class='hilight'>Graphical representation of
                        <code>istream</code>:</span>
                        <figure>
                            <img src="graphics/Chap10Diag2.png" width="50%">
                        </figure>
                    </p>
                    <br><br>
                    <p>
                      <code>ostream</code>:
                      <br>
                      <ul>
                        <li>
                          The type <code>ostream</code> to deal with streams
                          of output.
                        </li>
                        <li>
                          It turns values of various types into character
                          sequences.
                        </li>
                        <li>
                          Sends those characters “somewhere”
                          (such as to a console, a file, the main memory,
                          or another computer).
                        </li>
                      </ul>
                    </p>
                    <p>
                      <span class='hilight'>Graphical representation of
                        <code>ostream</code>:</span>
                        <figure>
                            <img src="graphics/Chap10Diag3.png" width="50%">
                        </figure>
                    </p>
                    <br><br>
                    <p>
                      <i>
                        In I/O Streams, buffering is important for dealing
                        with large amounts of data.
                      </i>
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    10.3 Files
                    </summary>
                    <figure>
                        <img src="graphics/Chap10Diag4.png" width="50%">
                    </figure>
                    <p>
                      At the most basic level,
                      a <i>file</i> is simply a sequence of bytes numbered from
                      0 upward. A <i>file</i> has a format; i.e,
                      it has a set of rules that determine what the bytes mean
                      (Eg. character vs binary representation).
                    </p>
                    <br>
                    <p>
                      While <span class="hilight">reading a file</span>
                        , we should:
                      <ul>
                        <li>
                          Know its name
                        </li>
                        <li>
                          Open it (for reading)
                        </li>
                        <li>
                          Read in the characters
                        </li>
                        <li>
                          Close it
                        </li>
                      </ul>
                    </p>
                    <br>
                    <p>
                      While <span class="hilight">writing a file</span>
                      , we should:
                      <ul>
                        <li>
                          Name it
                        </li>
                        <li>
                          Open it (for writing) or create a new file of
                          that name
                        </li>
                        <li>
                          Write out our objects
                        </li>
                        <li>
                          Close it (though that is typically done implicitly)
                        </li>
                      </ul>
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    10.4 Opening a file
                    </summary>
                    <figure>
                        <img src="graphics/Chap10Diag5.png" width="15%">
                    </figure>
                    <p>
                      <ul>
                        <li>
                          An <code>ifstream</code> is an <code>istream</code>
                          for reading from a file.
                        </li>
                        <li>
                          An <code>ofstream</code> is an <code>ostream</code>
                          for writing to a file.
                        </li>
                        <li>
                          A <code>fstream</code> is an <code>iostream</code>
                          that can be used for both reading and writing.
                        </li>
                      </ul>
                    </p>
                    <br>
                    <p>
                       Before a file stream can be used it must be
                       attached to a file:
                       <br>
                       <span class="hilight">Example:</span>
                       <PRE>
                         <code>
      cout &lt;&lt; "Please enter input file name: ";
      string iname;
      cin &gt;&gt; iname;
      ifstream ist {iname}; <span class="comment">// ist is an input stream for the file named name</span>
      if (!ist) error("can't open input file ",iname);
                        </code>
                      </PRE>
                    </p>
                    <p>
                      Defining an <code>ifstream</code> with a name string
                      opens the file of that name for reading.
                      The test of <code>!ist</code> checks if the
                      file was properly opened.
                      After that, we can read from the file
                      exactly as we would from any other <code>istream</code>.
                      <i>Output to files can be handled in a similar way by
                      <code>ofstreams</code>.</i>
                    </p>
                    <br>
                    <p>
                      Explicit <code>open()</code> and <code>close()</code>
                      operations can be performed. However, relying on scope
                      minimizes the chances of someone trying to use a
                      file stream before it has been attached to a stream or
                      after it was closed:
                      <br>
                      <span class="hilight">Example:</span>
                      <PRE>
                        <code>
                          ifstream ifs;
                          <span class="comment">// . . .</span>
                          ifs &gt;&gt; foo; <span class="comment">// won’t succeed: no file opened for ifs</span>
                          <span class="comment">// . . .</span>
                          ifs.open(name,ios_base::in); <span class="comment">// open file named name for reading</span>
                          <span class="comment">// . . .</span>
                          ifs.close(); <span class="comment">// close file</span>
                          <span class="comment">// . . .</span>
                          ifs &gt;&gt; bar; <span class="comment">// won’t succeed: ifs’ file was closed</span>
                          <span class="comment">// . . .</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      Also, you can’t open a file stream a second
                      time without first closing it:
                      <br>
                      <span class="hilight">Example:</span>
                      <PRE>
                        <code>
                        fstream fs;
                        fs.open("foo", ios_base::in) ; <span class="comment">// open for input</span>
                        <span class="comment">// close() missing</span>
                        fs.open("foo", ios_base::out); <span class="comment">// won’t succeed: fs is already open</span>
                        if (!fs) error("impossible");
                        </code>
                      </PRE>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    10.5 Reading and writing a file
                    </summary>
                    <figure>
                        <img src="graphics/Chap10Diag6.jpg" width="35%">
                    </figure>
                    <p>
                      Consider these temperature readings from a
                      weather station:
                      <br>
                        <code>
                          0 60.7
                          <br>
                          1 60.6
                          <br>
                          2 60.3
                          <br>
                          3 59.22
                          <br>
                          . . .
                        </code>
                    </p>
                    <p>
                      The hours are numbered <code>0</code> to
                      <code>23</code> and the temperatures are in
                      Fahrenheit. No further formatting is assumed.
                    </p>
                    <br>
                    <p>
                      Here, represent a temperature reading by a Reading type:
                      <PRE>
                        <code>
  struct Reading { <span class="comment">// a temperature reading</span>
  int hour; <span class="comment">// hour after midnight [0:23]</span>
  double temperature; <span class="comment">// in Fahrenheit</span>
  };
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      Given that, we could read like this:
                      <PRE>
                        <code>
  vector&lt;Reading&gt; temps; <span class="comment">// store the readings here</span>
  int hour;
  double temperature;
  while (ist &gt;&gt; hour &gt;&gt; temperature) {
        if (hour &lt; 0 || 23 &lt; hour) error("hour out of range");
        temps.push_back(Reading{hour,temperature});
  }
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      For writing, we can use the output file stream
                      (<code>ofstream</code>) if we might want to output
                      the readings with each pair of values in parentheses:
                      <PRE>
                        <code>
for (int i=0; i&lt;temps.size(); ++i)
      ost &lt;&lt; '(' &lt;&lt; temps[i].hour &lt;&lt; ',' &lt;&lt; temps[i].temperature &lt;&lt; ")\n";
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      The file streams automatically close their files
                      when they go out of scope, the complete program becomes:
                      <PRE>
                        <code>
#include "std_lib_facilities.h"

struct Reading { <span class="comment">// a temperature reading</span>
    int hour; <span class="comment">// hour after midnight [0:23]</span>
    double temperature; <span class="comment">// in Fahrenheit</span>
};

int main()
{
    cout &lt;&lt; "Please enter input file name: ";
    string iname;
    cin &gt;&gt; iname;
    ifstream ist {iname}; <span class="comment">// ist reads from the file named iname</span>
    if (!ist) error("can't open input file ",iname);

    string oname;
    cout &lt;&lt; "Please enter name of output file: ";
    cin &gt;&gt; oname;
    ofstream ost {oname}; <span class="comment">// ost writes to a file named oname</span>
    if (!ost) error("can't open output file ",oname);

    vector&lt;Reading&gt; temps; <span class="comment">// store the readings here</span>
    int hour;
    double temperature;
    while (ist &gt;&gt; hour &gt;&gt; temperature) {
        if (hour &lt; 0 || 23 &lt; hour) error("hour out of range");
        temps.push_back(Reading{hour,temperature});
    }
    for (int i=0; i&lt;temps.size(); ++i)
        ost &lt;&lt; '(' &lt;&lt; temps[i].hour &lt;&lt; ','
              &lt;&lt; temps[i].temperature &lt;&lt; ")\n";
}
                        </code>
                      </PRE>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                        Drill
                    </summary>

                    <p>
                     We want to convert a delimited file. Let's assume
                     the delimiter in the existing file is a comma,
                     and we want to convert it to a tab. Write a small
                     program that accepts "file.comma" as input,
                     and writes to "file.tab" as output.
                    </p>


                </details>


                <details>
                    <summary class="sum1">
                    10.6 I/O error handling
                    </summary>
                    <p>
                      The possibilities for input errors are limitless!
                      However, an istream reduces all to four possible cases,
                      called the <i>stream state</i>:
                      <table style="width:80%" align="center">
                        <tr>
                          <th colspan="2">Stream states</th>
                        </tr>
                        <tr>
                          <td>
                            good()
                          </td>
                          <td>
                            The operation succeeded
                          </td>
                        </tr>
                        <tr>
                          <td>
                            eof()
                          </td>
                          <td>
                            We hit end of input ("end of file")
                          </td>
                        </tr>
                        <tr>
                          <td>
                            fail()
                          </td>
                          <td>
                            Something unexpected happened (Eg. we looked for
                            a digit and found 'x')
                          </td>
                        </tr>
                        <tr>
                          <td>
                            bad()
                          </td>
                          <td>
                            Something unexpected and serious happened
                            (Eg. a disk read error)
                          </td>
                        </tr>
                      </table>
                    </p>
                    <br>
                    <p>
                      <span class="hilight">Example:</span> Consider how to read
                       a sequence of integers that may be terminated by the
                       character * or an “end of file” into a
                       <code>vector</code>.
                      <br>
                      <code>1 2 3 4 5 *</code>
                      <br>
                      This could be done using a function like this:
                      <br>
                      <PRE>
                        <code>
  void fill_vector(istream& ist, vector&lt;int&gt;& v, char terminator)
  <span class="comment">// read integers from ist into v until we reach eof() or terminator</span>
  {
      for (int i; ist &gt;&gt; i; )
          v.push_back(i);
      if (ist.eof())
          return; <span class="comment">// fine: we found the end of file</span>

      <span class="comment">// not good() and not bad() and not eof(), ist must be fail()</span>
      ist.clear(); <span class="comment">// clear stream state</span>

      char c;
      ist&gt;&gt;c; <span class="comment">// read a character, hopefully terminator</span>

      if (c != terminator) { <span class="comment">// ouch: not the terminator, so we must fail</span>
          ist.unget(); <span class="comment">// maybe my caller can use that character</span>
          ist.clear(ios_base::failbit); <span class="comment">// set the state to fail()</span>
      }
  }
                        </code>
                      </PRE>
                    </p>
                    <p>
                      Since we cleared the state to be able to
                      examine the character, we have to set the stream
                      state back to <code>fail()</code>.
                      We do that with <code>ist.clear(ios_base::failbit)</code>.
                      <br>
                      The <code>ios_base</code> that appears here and there is
                      the part of an <code>iostream</code> that holds
                      constants such as <code>badbit</code>, exceptions such as
                      <code>failure</code>.
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    10.7 Reading a single value
                    </summary>
                    <p>
                      Lets say we are trying to read a single value
                      from the user and we are trying to solve the simple
                      problem of
                      <i>“how to get an acceptable value from the user.”</i>
                      <br>
                      Here we deal with 3 different conditions/errors:
                      <ul>
                        <li>
                          The user typing an out-of-range value
                        </li>
                        <li>
                          Getting no value (end of file)
                        </li>
                        <li>
                          The user typing something of the wrong type
                          (here, not an integer)

                        </li>
                      </ul>
                    </p>
                    <br>
                    <p>
                      For the above 3 errors we have 3 alternatives:
                      <br>
                      <ul>
                        <li>
                          Handle the problem in the code doing the read.
                        </li>
                        <li>
                          Throw an exception to let someone else handle
                          the problem (potentially terminating the program).
                        </li>
                        <li>
                          Ignore the problem.
                        </li>
                      </ul>
                    </p>
                    <details>
                        <summary class="sum2">
                        10.7.1 Breaking the problem into manageable parts
                        </summary>
                        <p>
                          <PRE>
    <code>
      cout &lt;&lt; "Please enter an integer in the range 1 to 10 (inclusive):\n";
      int n = 0;
      while (true)
      {
          cin &gt;&gt; n;
          if (cin)
          { <span class="comment">// we got an integer; now check it</span>
              if (1&lt;=n && n&lt;=10)
                  break;
              cout &lt;&lt; "Sorry "
                    &lt;&lt; n &lt;&lt; " is not in the [1:10] range; please try again\n";
          }
          else if (cin.fail())
               { <span class="comment">// we found something that wasn’t an integer</span>
                  cin.clear(); <span class="comment">// set the state back to good();</span>
                              <span class="comment">// we want to look at the characters</span>
                  cout &lt;&lt; "Sorry, that was not a number; please try again\n";
                  for (char ch; cin&gt;&gt;ch && !isdigit(ch); ) <span class="comment">// throw away non-digits</span>
                      <span class="comment">/* nothing */ ;</span>
                      if (!cin)
                          error("no input"); <span class="comment">// we didn’t find a digit: give up</span>
                      cin.unget(); <span class="comment">// put the digit back, so that we can read the number</span>
               }
               else
               {
                      error("no input"); <span class="comment">// eof or bad: give up</span>
               }
      }
      <span class="comment">// if we get here n is in [1:10]</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Few reasons that the code becomes messy are
                          listed below:
                          <ul>
                            <li>
                              Reading values
                            </li>
                            <li>
                              Prompting the user for input
                            </li>
                            <li>
                              Writing error messages
                            </li>
                            <li>
                              Skipping past “bad” input characters
                            </li>
                            <li>
                              Testing the input against a range
                            </li>
                          </ul>
                        </p>
                        <br>
                        <br>
                        <p>
                          The code can be reduced to:
                          <PRE>
                            <code>
      void skip_to_int()
      {
          if (cin.fail())
          { <span class="comment">// we found something that wasn’t an integer</span>
              cin.clear(); <span class="comment">// we’d like to look at the characters</span>
              for (char ch; cin&gt;&gt;ch; )
              { <span class="comment">// throw away non-digits</span>
                  if (isdigit(ch) || ch=="-")
                  {
                      cin.unget(); <span class="comment">// put the digit back,</span>
                                    <span class="comment">// so that we can read the number</span>
                      return;
                  }
              }
      }
      error("no input"); <span class="comment">// eof or bad: give up</span>
      }


      cout &lt;&lt; "Please enter an integer in the range 1 to 10 (inclusive):\n";
      int n = 0;
      while (true)
      {
          if (cin&gt;&gt;n)
          { <span class="comment">// we got an integer; now check it</span>
              if (1&lt;=n && n&lt;=10)
                  break;
              cout &lt;&lt; "Sorry " &lt;&lt; n
                    &lt;&lt; " is not in the [1:10] range; please try again\n";
          }
          else
          {
              cout &lt;&lt; "Sorry, that was not a number; please try again\n";
              skip_to_int();
          }
      }
      <span class="comment">// if we get here n is in [1:10]</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          But the above code is still long and messy.
                          Further, we can make a function to do the above task.
                          <PRE>
                            <code>
      int get_int(); <span class="comment">// read an int from cin</span>
      int get_int(int low, int high); <span class="comment">// read an int in [low:high] from cin</span>

      int get_int()
      {
          int n = 0;
          while (true)
          {
              if (cin &gt;&gt; n)
                  return n;
              cout &lt;&lt; "Sorry, that was not a number; please try again\n";
              skip_to_int();
          }
      }

      int get_int(int low, int high)
      {
          cout &lt;&lt; "Please enter an integer in the range "
                &lt;&lt; low &lt;&lt; " to " &lt;&lt; high &lt;&lt; " (inclusive):\n";
          while (true)
          {
              int n = get_int();
              if (low&lt;=n && n&lt;=high)
                  return n;
              cout &lt;&lt; "Sorry "
                    &lt;&lt; n &lt;&lt; " is not in the [" &lt;&lt; low &lt;&lt; ':' &lt;&lt; high
                    &lt;&lt; "] range; please try again\n";
          }
      }
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Now we can read integers reliably as follows:
                          <PRE>
                            <code>
      int n = get_int(1,10);
      cout &lt;&lt; "n: " &lt;&lt; n &lt;&lt; '\n';
      int m = get_int(2,300);
      cout &lt;&lt; "m: " &lt;&lt; m &lt;&lt; '\n';
                            </code>
                          </PRE>
                        </p>
                    </details>
                    <details>
                        <summary class="sum2">
                        10.7.2 Separating dialog from function
                        </summary>
                        <p>
                          In the above example, the <code>get_int()</code>
                          functions still mix up reading with writing
                          messages to user.
                          Instead we can call <code>get_int()</code> like this:
                          <PRE>
                            <code>
    int strength = get_int(1,10, "enter strength", "Not in range, try again");
    cout &lt;&lt; "strength: " &lt;&lt; strength &lt;&lt; '\n';
    int altitude = get_int(0,50000,
                        "Please enter altitude in feet",
                        "Not in range, please try again");
    cout &lt;&lt; "altitude: " &lt;&lt; altitude &lt;&lt; "f above sea level\n";


    int get_int(int low, int high, const string& greeting, const string& sorry)
    {
        cout &lt;&lt; greeting &lt;&lt; ": [" &lt;&lt; low &lt;&lt; ':' &lt;&lt; high &lt;&lt; "]\n";
        while (true)
        {
            int n = get_int();
            if (low&lt;=n && n&lt;=high)
                return n;
            cout &lt;&lt; sorry &lt;&lt; ": [" &lt;&lt; low &lt;&lt; ':' &lt;&lt; high &lt;&lt; "]\n";
          }
    }
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          The point here is that “utility functions”
                          used in many parts of a program shouldn’t
                          have messages “hardwired” into them.
                        </p>
                    </details>
                </details>
                <details>
                    <summary class="sum1">
                    10.8 User-defined output operators
                    </summary>
                    <p>
                      The output operator <code>&lt;&lt;</code>
                      can be used in the following ways:
                      <br>
                      Simple output operator for <code>Date</code>
                      <PRE>
                        <code>
  ostream& operator&lt;&lt;(ostream& os, const Date& d)
  {
      return os &lt;&lt; '(' &lt;&lt; d.year()
                  &lt;&lt; ',' &lt;&lt; d.month()
                  &lt;&lt; ',' &lt;&lt; d.day() &lt;&lt; ')';
  }
                        </code>
                      </PRE>
                    </p>
                    <p>
                      This prints August 30, 2004, as <code>(2004,8,30)</code>
                      <br>
                      <br>
                      Given the definition of <code>&lt;&lt;</code>
                      for <code>Date</code>, the meaning of:
                      <br>
                      <code>
                        cout &lt;&lt; d1;
                      </code>
                      <br>
                      where <code>d1</code> is a <code>Date</code> is the call
                      <br>
                      <br>
                      <code>
                        operator&lt;&lt;(cout,d1);
                      </code>
                      <br>
                      Also, <code>operator&lt;&lt;()</code>
                      takes an <code>ostream&</code> as its
                      first argument and returns it again as its return value.
                      We can "chain" output operations.
                      <PRE>
                        <code>
cout &lt;&lt; d1 &lt;&lt; d2; <span class="comment">// means operator&lt;&lt;(cout,d1) &lt;&lt; d2;</span>
                  <span class="comment">// means operator&lt;&lt;(operator&lt;&lt;(cout,d1),d2);</span>
                        </code>
                      </PRE>
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    10.9 User-defined input operators
                    </summary>
                    <p>
                      The input operator <code>&gt;&gt;</code>
                      can be used in the following ways:
                      <br>
                      Simple input operator for <code>Date</code>
                      <PRE>
                        <code>
  istream&amp; operator&gt;&gt;(istream&amp; is, Date&amp; dd)
  {
      int y, m, d;
      char ch1, ch2, ch3, ch4;
      is &gt;&gt; ch1 &gt;&gt; y &gt;&gt; ch2 &gt;&gt; m &gt;&gt; ch3 &gt;&gt; d &gt;&gt; ch4;
      if (!is) return is;
      if (ch1!='(' || ch2!=',' || ch3!=',' || ch4!=')')
      {   <span class="comment">// oops: format error</span>
          is.clear(ios_base::failbit);
          return is;
      }
      dd = Date{y,Date::Month(m),d}; <span class="comment">// update dd</span>
      return is;
  }
                        </code>
                      </PRE>
                    </p>
                    <p>
                      This reads items like <code>(2004,8,20)</code>
                      and try to make a <code>Date</code> out of those
                      3 integers.
                      <br>
                      If the <code>input operator&gt;&gt;()</code>
                      reads an invalid Date, say <code>(2004,8,35)</code>,
                      Date’s constructor will throw an exception,
                      getting out of this <code>operator&gt;&gt;()</code>.
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    10.10 A standard input loop
                    </summary>
                    <p>
                      Here is how we can check our input file reads as we go
                      along:
                      <br>
                      <br>
                      Assuming <code>ist</code> is an <code>istream</code>,
                      <PRE>
                        <code>
for (My_type var; ist&gt;&gt;var; )
{   <span class="comment">// read until end of file</span>
    <span class="comment">// maybe check that var is valid</span>
    <span class="comment">// do something with var</span>
}
<span class="comment">// we can rarely recover from bad; don’t try unless you really have to:</span>
if (ist.bad())
    error("bad input stream");
if (ist.fail())
{
    <span class="comment">// was it an acceptable terminator?</span>
}
<span class="comment">// carry on: we found end of file</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      Improving <code>istream</code> by
                      letting it throw an exception of type
                      <code>failure</code>,
                      <PRE>
<code>
<span class="comment">// somewhere: make ist throw an exception if it goes bad:</span>
ist.exceptions(ist.exceptions()|ios_base::badbit);
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      Also, deciding to designate a character as a terminator,
                      <PRE>
                        <code>
for (My_type var; ist&gt;&gt;var; )
{   <span class="comment">// read until end of file</span>
    <span class="comment">// maybe check that var is valid</span>
    <span class="comment">// do something with var</span>
}
if (ist.fail())
{   <span class="comment">// use '|' as terminator and/or separator</span>
    ist.clear();
    char ch;
    if (!(ist&gt;&gt;ch && ch=='|'))
        error("bad termination of input");
}
<span class="comment">// carry on: we found end of file or a terminator</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      Making the code simpler using a function:
                      <PRE>
                        <code>
  <span class="comment">// somewhere: make ist throw if it goes bad:</span>
  ist.exceptions(ist.exceptions()|ios_base::badbit);
  void end_of_loop(istream& ist, char term, const string& message)
  {
      if (ist.fail())
      {   <span class="comment">// use term as terminator and/or separator</span>
          ist.clear();
          char ch;
          if (ist&gt;&gt;ch && ch==term)
              return; <span class="comment">// all is fine</span>
          error(message);
       }
  }

  for (My_type var; ist&gt;&gt;var; )
  {   <span class="comment">// read until end of file</span>
      <span class="comment">// maybe check that var is valid</span>
      <span class="comment">// . . . do something with var . . .</span>
  }
  end_of_loop(ist,'|',"bad termination of file"); <span class="comment">// test if we can continue</span>
  <span class="comment">// carry on: we found end of file or a terminator</span>
                        </code>
                      </PRE>
                    </p>
                    <p>
                      Unless the stream is in the
                      <code>fail()</code> state, <code>end_of_loop()</code>
                      does nothing.
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    10.11 Reading a structured file
                    </summary>
                    <p>
                      Assume that you have a file of temperature
                      readings that has been structured like this:
                      <ul>
                        <li>
                          A file holds years (of months of readings).
                          <br>
                          A year starts with { year followed by an
                              integer giving the year, such as 1900, and
                              ends with }.
                        </li>
                        <li>
                          A year holds months (of days of readings).
                          <br>
                          A month starts with { month followed by a
                          three-letter month name, such as jan,
                          and ends with }.
                        </li>
                        <li>
                          A reading holds a time and a temperature.
                          <br>
                          A reading starts with a ( followed by day of the
                          month, hour of the day, and temperature
                          and ends with a ).
                        </li>

                      </ul>
                    </p>
                    <br>
                    <p>
                        <span class ="hilight">Example:</span>
                        <br>
                        <PRE>
                          <code>
      { year 1990 }
      {year 1991 { month jun }}
      { year 1992 { month jan ( 1 0 61.5) } {month feb (1 1 64) (2 2 65.2) } }
      {year 2000
            { month feb (1 1 68 ) (2 3 66.66 ) ( 1 0 67.2)}
            {month dec (15 15 –9.2 ) (15 14 –8.8) (14 0 –2) }
      }
                          </code>
                        </PRE>
                    </p>
                    <br>
                    <p>
                      The above format is a little unusual.
                      Though there is a move towards hierarchically
                      structured files (HTML and XML files) but
                      still we can hardly control the input structure
                      of files that are read.
                      <br>
                      <br>
                      To suit our needs, we can choose the in-memory
                      representation of data and we can often pick output
                      formats.
                    </p>
                    <details>
                        <summary class="sum2">
                        10.11.1 In-memory representation
                        </summary>
                        <p>
                          The first choice to represent this
                          data in memory will be classes:
                          <code> Year, Month and Reading</code>
                          <br>
                          <br>
                          But <code>Reading (day of month, hour of day,
                            temperature)</code> is “odd” and makes
                            sense only within a Month.
                            It is also unstructured.
                          <br>
                          <br>
                          Better way of representation will be as,
                          <br>
                          <code>Year</code> as a <code>vector</code> of 12
                            <code>Months</code>,
                          <br>
                          <code>Month</code> as a <code>vector</code>
                          of about 30 <code>Days</code>,
                          <br>
                          <code>Day</code> as 24 temperatures (one per hour)
                          <br>
                          <br>
                          <code>Day</code>, <code>Month</code>, and
                          <code>Year</code> are simple data
                          structures, each with a constructor.
                          <br>
                          We need to have a notion of “not a reading”
                          for an hour of a day for which we haven’t
                          (yet) read data,
                          <br>
                            <code>
                            const int not_a_reading = –7777;
                            <span class="comment">// less than absolute zero</span>
                            </code>
                          <br>
                        </p>
                        <br>
                        <p>
                          For a month without data,
                          <br>
                          <code>
                          const int not_a_month = –1;
                          </code>
                          <br>
                          <br>
                          The 3 classes will be,
                          <br>
                          <PRE>
                            <code>
                              struct Day
                              {
                                  vector&lt;double&gt; hour {vector&lt;double&gt;(24,not_a_reading)};
                              };

                              struct Month
                              {   <span class="comment">// a month of temperature readings</span>
                                  int month {not_a_month}; <span class="comment">// [0:11] January is 0</span>
                                  vector&lt;Day&gt; day {32}; <span class="comment">// [1:31] one vector of readings per day</span>
                              };

                              struct Year
                              {    <span class="comment">// a year of temperature readings, organized by month</span>
                                  int year;  <span class="comment">// positive == A.D.</span>
                                  vector&lt;Month&gt; month {12}; <span class="comment">// [0:11] January is 0</span>
                              };
                            </code>
                          </PRE>
                        </p>
                    </details>
                    <details>
                        <summary class="sum2">
                        10.11.2 Reading structured values
                        </summary>
                        <p>
                          The <code>Reading</code> class,
                          <PRE>
                            <code>
                              struct Reading
                              {
                                  int day;
                                  int hour;
                                  double temperature;
                              };

                              istream& operator&gt;&gt;(istream& is, Reading& r)
                              <span class="comment">// read a temperature reading from is into r</span>
                              <span class="comment">// format: ( 3 4 9.7 )</span>
                              <span class="comment">// check format, but don’t bother with data validity</span>
                              {
                                  char ch1;
                                  if (is&gt;&gt;ch1 && ch1!='(')
                                  {   <span class="comment">// could it be a Reading?</span>
                                      is.unget();
                                      is.clear(ios_base::failbit);
                                      return is;
                                  }
                                  char ch2;
                                  int d;
                                  int h;
                                  double t;
                                  is &gt;&gt; d &gt;&gt; h &gt;&gt; t &gt;&gt; ch2;
                                  if (!is || ch2!=')')
                                      error("bad reading"); <span class="comment">// messed-up reading</span>
                                  r.day = d;
                                  r.hour = h;
                                  r.temperature = t;
                                  return is;
                              }
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          The <code>Month</code> input operation,
                          <PRE>
                            <code>
                    istream& operator&gt;&gt;(istream& is, Month& m)
                    <span class="comment">// read a month from is into m</span>
                    <span class="comment">// format: { month feb . . . }</span>
                    {
                        char ch = 0;
                        if (is &gt;&gt; ch && ch!='{')
                        {
                            is.unget();
                            is.clear(ios_base::failbit); <span class="comment">// we failed to read a Month</span>
                            return is;
                        }

                        string month_marker;
                        string mm;
                        is &gt;&gt; month_marker &gt;&gt; mm;
                        if (!is || month_marker!="month")
                            error("bad start of month");
                        m.month = month_to_int(mm);
                        int duplicates = 0;
                        int invalids = 0;
                        for (Reading r; is &gt;&gt; r; )
                        {
                            if (is_valid(r))
                            {
                                if (m.day[r.day].hour[r.hour] != not_a_reading)
                                    ++duplicates;
                                m.day[r.day].hour[r.hour] = r.temperature;
                            }
                            else
                                ++invalids;
                        }
                        if (invalids)
                            error("invalid readings in month",invalids);
                        if (duplicates)
                            error("duplicate readings in month", duplicates);
                        end_of_loop(is,'}',"bad end of month");
                        return is;
                    }
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          <code>Month’s &gt;&gt;</code> does a quick check that
                          a <code>Reading</code> is plausible before storing
                          it:
                          <PRE>
                            <code>
                              constexpr int implausible_min = –200;
                              constexpr int implausible_max = 200;
                              bool is_valid(const Reading& r)
                              <span class="comment">// a rough test</span>
                              {
                              if (r.day&lt;1 || 31&lt;r.day)
                                  return false;
                              if (r.hour&lt;0 || 23&lt;r.hour)
                                  return false;
                              if (r.temperature&lt;implausible_min|| implausible_max&lt;r.temperature)
                                  return false;
                              return true;
                              }
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          <code>Year’s &gt;&gt;</code> is similar to
                          <code>Month’s &gt;&gt;</code>,
                          <PRE>
                            <code>
                              istream& operator&gt;&gt;(istream& is, Year& y)
                              <span class="comment">// read a year from is into y</span>
                              <span class="comment">// format: { year 1972 . . . }</span>
                              {
                                  char ch;
                                  is &gt;&gt; ch;
                                  if (ch!='{')
                                  {
                                      is.unget();
                                      is.clear(ios::failbit);
                                      return is;
                                  }

                                  string year_marker;
                                  int yy;
                                  is &gt;&gt; year_marker &gt;&gt; yy;
                                  if (!is || year_marker!="year")
                                      error("bad start of year");
                                  y.year = yy;
                                  while(true)
                                  {
                                      Month m; <span class="comment">// get a clean m each time around</span>
                                      if(!(is &gt;&gt; m))
                                          break;
                                      y.month[m.month] = m;
                                  }
                                  end_of_loop(is,'}',"bad end of year");
                                  return is;
                              }
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          But here the problem is that,
                          <code>operator&gt;&gt;(istream& is, Month& m)</code>
                          doesn’t assign a brand-new value to m; it
                          simply adds data from
                          <code>Readings</code> to <code>m</code>.
                          We make a new Month to read into each time we
                          do <code>is&gt;&gt;m</code>.
                          <PRE>
                            <code>
                              for (Month m; is &gt;&gt; m; )
                              {
                                y.month[m.month] = m;
                                m = Month{}; <span class="comment">// “reinitialize” m</span>
                              }
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Try using the above,
                          <PRE>
                            <code>
                            <span class="comment">// open an input file:</span>
                            cout &lt;&lt; "Please enter input file name\n";
                            string iname;
                            cin &gt;&gt; iname;
                            ifstream ist {iname};
                            if (!ifs)
                                error("can't open input file",iname);
                            ifs.exceptions(ifs.exceptions()|ios_base::badbit); <span class="comment">// throw for bad()</span>

                            <span class="comment">// open an output file:</span>
                            cout &lt;&lt; "Please enter output file name\n";
                            string oname;
                            cin &gt;&gt; oname;
                            ofstream ost {oname};
                            if (!ofs)
                                error("can't open output file",oname);

                            <span class="comment">// read an arbitrary number of years:</span>
                            vector&lt;Year&gt; ys;
                            while(true)
                            {
                                Year y; <span class="comment">// get a freshly initialized Year each time around</span>
                                if (!(ifs&gt;&gt;y))
                                    break;
                                ys.push_back(y);
                            }
                            cout &lt;&lt; "read " &lt;&lt; ys.size() &lt;&lt; " years of readings\n";
                            for (Year& y : ys)
                                print_year(ofs,y);
                            </code>
                          </PRE>
                        </p>
                    </details>
                    <details>
                        <summary class="sum2">
                        10.11.3 Changing representations
                        </summary>
                        <p>
                          The tedious way to get <code>Months's &gt;&gt;</code>
                          to work will be
                          <PRE>
                            <code>
                            if (s=="jan")
                                m = 1;
                            else if (s=="feb")
                                     m = 2;
                            <span class="comment">. . .</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Instead we represent input as a
                          <code>vector&lt;string&gt;</code>
                          with an initialization function and a
                          lookup function,
                          <PRE>
                            <code>
                              vector&lt;string&gt; month_input_tbl = {
                              "jan", "feb", "mar", "apr", "may", "jun", "jul",
                              "aug", "sep", "oct", "nov", "dec"
                              };

                              int month_to_int(string s)
                              <span class="comment">// is s the name of a month? If so return its index [0:11] otherwise –1</span>
                              {
                                  for (int i=0; i&lt;12; ++i)
                                      if (month_input_tbl[i]==s)
                                          return i;
                                  return –1;
                              }
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          While producing output,
                          we would like the symbolic representation of month
                          to be printed,
                          <PRE>
                            <code>
                vector&lt;string&gt; month_print_tbl = {
                "January", "February", "March", "April", "May", "June", "July",
                "August", "September", "October", "November", "December"
                };

                string int_to_month(int i)
                <span class="comment">// months [0:11]</span>
                {
                    if (i&lt;0 || 12&lt;=i)
                        error("bad month index");
                    return month_print_tbl[i];
                }
                            </code>
                          </PRE>
                        </p>
                    </details>
                </details>

                <details>
                    <summary class="sum1">
                    Test Yourself!
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Exams_in_Jaura%2C_India.jpg/560px-Exams_in_Jaura%2C_India.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>
<!-- Include the test material here! -->
                </details>

                <details>
                    <summary class="sum1">
                    Drill
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Queens.guard.buck.palace.arp.jpg/600px-Queens.guard.buck.palace.arp.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>

                    <ol>
                    </ol>
                </details>
            </div>
        </div>

    </body>
</html>

<!DOCTYPE html>
<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <link rel="stylesheet" href="style.css">

        <!-- jQuery CDN -->
         <script src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
         <!-- Bootstrap Js CDN -->
         <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

         <script type="text/javascript">
             var status = 'on';
             $(document).ready(function () {
                 $('#sidebarCollapse').on('click', function () {
                     $('#sidebar').toggleClass('active');
                     if (status == 'on') {
                         $('#sidebarText').text("Expand Side Nav");
                         status = 'off';
                     } else {
                         $('#sidebarText').text("Collapse Side Nav");
                         status = 'on';
                     }
                 });
             });
         </script>
        <title>
            17. Vector and Free Store
        </title>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114841175-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-114841175-1');
</script>
    </head>

    <body>
        <div class="wrapper">
<!-- Sidebar Holder -->
<nav id="sidebar">
        <div id="sidebarCollapse">
        <div class="sidebar-header">
            <h1>
            Object-Oriented Programming
            </h1>
            <strong>OOP</strong>
        </div>
    </div>
    <ul class="list-unstyled components">
        <li>
        <a href="index.html">
        <i class="glyphicon glyphicon-home"></i>
        Home
        </a>
        </li>
        <li>
        <a href="#Submenu0" data-toggle="collapse" aria-expanded="false">
        <i class="glyphicon glyphicon-list"></i>
        Topics
        </a>
        </li>
        <ul class="collapse list-unstyled" id="Submenu0">
            <li>
            <a href="#Submenu1" data-toggle="collapse" aria-expanded="false">
            Part I: The Basics
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu1">
                <li>
                <a href="hello.html">
                2. Hello, World!
                </a>
                </li>
                <li>
                <a href="otv.html">
                3. Objects, Types, and Values
                </a>
                </li>
                <li>
                <a href="computation.html">
                4. Computation
                </a>
                </li>
                <li>
                <a href="errors.html">
                5. Errors
                </a>
                </li>
                <li>
                <a href="writing.html">
                6. Writing a Program
                </a>
                </li>
                <li>
                <a href="completing.html">
                7. Completing a Program
                </a>
                </li>
                <li>
                <a href="functions.html">
                8. Technicalities: Functions, etc.
                </a>
                </li>
                <li>
                <a href="classes.html">
                9. Technicalities: Classes, etc.
                </a>
                </li>
            </ul>
            <li>
            <a href="#Submenu2" data-toggle="collapse" aria-expanded="false">
            Part II: Input and Output
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu2">
                <li>
                <a href="iostreams.html">
                10. Input and Output Streams
                </a>
                </li>
                <li>
                <a href="customizingio.html">
                11. Customizing Input and Output
                </a>
                </li>
                <li>
                <a href="display_model.html">
                12. A Display Model
                </a>
                </li>
                <li>
                <a href="graphics_classes.html">
                13. Graphics Classes
                </a>
                </li>
                <li>
                <a href="class_design.html">
                14. Graphics Class Design
                </a>
                </li>
                <li>
                <a href="graphing_funcs.html">
                15. Graphing Functions and Data
                </a>
                </li>
                <li>
                <a href="gui.html">
                16. Graphical User Interfaces
                </a>
                </li>
            </ul>
            <li>
            <a href="#Submenu3" data-toggle="collapse" aria-expanded="false">
            Part III: Data and Algorithms
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu3">
                <li>
                <a href="vector_free.html">
                17. Vector and Free Store
                </a>
                </li>
                <li>
                <a href="vector_array.html">
                18. Vectors and Arrays
                </a>
                </li>
                <li>
                <a href="vector_templ.html">
                19. Vector, Templates, and Exceptions
                </a>
                </li>
                <li>
                <a href="containers.html">
                20. Containers and Iterators
                </a>
                </li>
                <li>
                <a href="algorithms.html">
                21. Algorithms and Maps
                </a>
                </li>
            </ul>
            <li>
            <a href="#Submenu4" data-toggle="collapse" aria-expanded="false">
            Part IV Broadening the View
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu4">
                <li>
                <a href="history.html">
                22. Ideals and History
                </a>
                </li>
                <li>
                <a href="text.html">
                23. Text Manipulation
                </a>
                </li>
                <li>
                <a href="numerics.html">
                24. Numerics
                </a>
                </li>
                <li>
                <a href="embedded.html">
                25. Embedded Systems Programming
                </a>
                </li>
                <li>
                <a href="testing.html">
                26. Testing
                </a>
                </li>
                <li>
                <a href="C.html">
                27. The C Programming Language
                </a>
                </li>
            </ul>
        </ul>
        <li>
        <a href="#Submenu5" data-toggle="collapse" aria-expanded="false">
        <i class="glyphicon glyphicon-blackboard"></i>
        Other Materials
        </a>
        </li>
        <ul class="collapse list-unstyled" id="Submenu5">
            <li>
            <a href="syllabi/SyllabusSu2018.html">
            <i class="glyphicon glyphicon-tasks"></i>
            Course Syllabus
            </a>
            </li>
            <li>
            <a href="https://github.com/gcallah/OOP/tree/03c8d77c5ee5faae253d8a8e989aa347af0c3c45/code">
            <i class="glyphicon glyphicon-list-alt"></i>
            Source Code
            </a>
            </li>
            <li>
            <a href="tests/midterm_key.html">
            <i class="glyphicon glyphicon-pencil"></i>
            Midterm
            </a>
            </li>
            <li>
            <a href="http://www.stroustrup.com/programming.html">
            <i class="glyphicon glyphicon-book"></i>
            Our textbook's website
            </a>
            </li>
            <li>
            <a href="https://gcallah.github.io/utils/unix_guide.html">
            <i class="glyphicon glyphicon-hand-right"></i>
            Guide to UNIX
            </a>
            </li>
        </ul>
        <li>
        <a href="about.html">
        <i class="glyphicon glyphicon-info-sign"></i>
        About
        </a>
        </li>
    </ul>
</nav>
            <div id="content">
                <h1>
                    17. Vector and Free Store
                </h1>

                <p class="leadquote">
                "Use <code>vector</code> as the default."
                -- Alex Stepanov
                </p>

                <details>
                    <summary class="sum1">
                    17.1 Introduction
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a6/Vector_components_and_base_change.svg/400px-Vector_components_and_base_change.svg.png"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>

                    <p>
                        The most useful class in the standard C++ library is
                        <code>vector</code>.
                        We are going to undertake an adventure: we are going to
                        try to understand how <code>vector</code> was gradually
                        built to what we have today, why it was so designed,
                        and along the way we will gain some understanding of
                        how we might create our own container. We will also
                        gain an understanding of how computer programs work at
                        a deeper level than we have encountered before.
                    </p>

                    <p>
                        Why bother with all of these details? The reason is, if
                        we want to become true software professionals, we must
                        understand how our languages use the underlying
                        hardware!
                    </p>

                </details>

                <details>
                    <summary class="sum1">
                    17.2 vector basics
                    </summary>
                    <p>
                      <PRE>
                        <code>
vector&lt;double&gt; age(4); <span class="comment">// a vector with 4 elements of type double</span>
age[0]=0.33;
age[1]=22.0;
age[2]=27.2;
age[3]=54.2;
                        </code>
                      </PRE>
                      <br>
                      <figure>
                          <img src="graphics/Chap17Diag1.png" width="40%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      Elements of <code>age</code> are numbered
                      <code>0</code> to <code>age.size()-1</code>.
                      <br>
                      Defining a fixed-size data structure,
                      <br>
                      <PRE>
                        <code>
class vector {
    int size, age0, age1, age2, age3;
    // . . .
};
                        </code>
                      </PRE>
                      <br>
                      <figure>
                          <img src="graphics/Chap17Diag2.png" width="40%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      Adding an element with <code>push_back()</code> becomes
                      difficult as defined <code>vector</code> has fixed
                      number of elements.
                      <br>
                      We need a data member that points to the set of elements
                      so that it points to different set of elements
                      when more space is needed.
                      <br>
                      A <code>pointer</code> holds an address and is
                      distinguished by the suffix <code>*</code>
                      meaning "pointer to <code>double</code>".
                      <PRE>
                        <code>
<span class="comment">// a very simplified vector of doubles (like vector&lt;double&gt;)</span>
class vector {
    int sz; <span class="comment">// the size</span>
    double* elem; <span class="comment">// pointer to the first element (of type double)</span>
public:
    vector(int s); <span class="comment">// constructor: allocate s doubles,</span>
                  <span class="comment">// let elem point to them</span>
                  <span class="comment">// store s in sz</span>
int size() const { return sz; } <span class="comment">// the current size</span>
};
                        </code>
                      </PRE>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    17.3 Memory, addresses, and pointers
                    </summary>
                    <p>
                      An <code>address</code> is a "number that
                      indicates a location in memory".
                      <br>
                      <br>
                      A megabyte of memory can be visualized as following,
                      <figure>
                          <img src="graphics/Chap17Diag3.png" width="40%">
                      </figure>
                      <br>
                      <br>
                      <PRE>
                          <code>
int var = 17;
                          </code>
                      </PRE>
                    </p>
                    <p>
                      Here, an "int-size" piece of memory for
                      var is set aside and value 17 is put in memory.
                    </p>
                    <br>
                    <p>
                      <PRE>
<code>
int* ptr = &var; <span class="comment">// ptr holds the address of var</span>
</code>
                      </PRE>
                    </p>

                    <p>
                      The type needed to hold the address of an
                      <code>int</code> is “pointer to int” or
                      an “int pointer” and the notation is <code>int*</code>.
                      <br>
                      <br>
                      The “address of” operator, unary <code>&</code>,
                      is used to get the address of an object.
                      So, if <code>var</code> happens to start at address
                      <code>4096</code>, <code>ptr</code> will hold
                      the value <code>4096</code>:
                      <figure>
                          <img src="graphics/Chap17Diag4.png" width="40%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      Each type has a corresponding pointer type.
                      <PRE>
                        <code>
int x = 17;
int* pi = &x; <span class="comment">// pointer to int</span>
double e = 2.71828;
double* pd = &e; <span class="comment">// pointer to double</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      To see value of the object pointed to,
                      <PRE>
                        <code>
cout &lt;&lt; "pi==" &lt;&lt; pi &lt;&lt; "; contents of pi==" &lt;&lt; *pi &lt;&lt; "\n";
cout &lt;&lt; "pd==" &lt;&lt; pd &lt;&lt; "; contents of pd==" &lt;&lt; *pd &lt;&lt; "\n";
                        </code>
                      </PRE>
                    </p>
                    <p>
                      The output for <code>*pi</code> will be the integer
                      <code>17</code> and the output for <code>*pd</code>
                      will be the double <code>2.71828</code>.
                      <br>
                      The output for pi and pd will vary depending on
                      where the compiler allocated our variables x and e in
                      memory.
                    </p>
                    <br>
                    <p>
                      The contents of operator can also be used on the
                      left-hand side of an assignment:
                      <PRE>
                        <code>
*pi = 27; <span class="comment">// OK: you can assign 27 to the int pointed to by pi</span>
*pd = 3.14159; <span class="comment">// OK: you can assign 3.14159 to the double pointed to by pd</span>
*pd = *pi; <span class="comment">// OK: you can assign an int (*pi) to a double (*pd)</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      <code>int</code> provides the
                      operations suitable for integers.
                      <br>
                      A pointer type provides the operations suitable
                      for addresses.
                      <PRE>
                        <code>
int i = pi; <span class="comment">// error: can’t assign an int* to an int</span>
pi = 7; <span class="comment">// error: can’t assign an int to an int*</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      Also, a pointer to <code>char</code>
                      a <code>char*</code>) is not a pointer
                      to <code>int</code> (an <code>int*</code>):
                      <PRE>
                        <code>
char* pc = pi; <span class="comment">// error: can’t assign an int* to a char*</span>
pi = pc; <span class="comment">// error: can’t assign a char* to an int*</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      Why is it an error?
                      <PRE>
                        <code>
char ch1 = 'a';
char ch2 = 'b';
char ch3 = 'c';
char ch4 = 'd';
int* pi = &ch3; <span class="comment">// point to ch3, a char-size piece of memory</span>
                <span class="comment">// error: we cannot assign a char* to an int*</span>
                <span class="comment">// but let’s pretend we could</span>
*pi = 12345; <span class="comment">// write to an int-size piece of memory</span>
*pi = 67890;
                        </code>
                      </PRE>
                    </p>
                    <p>
                      If the compiler would have allowed the code,
                      <code>12345</code> would be written to the memory
                      starting at <code>&ch3</code>.
                      <br>
                      Then the next assignment <code>*pi=67890</code> would
                      place <code>67890</code> in some completely
                      different part of memory.
                      <br>
                      <br>
                      <i>
                        Thats why our aim is always to work at
                        highest level of abstraction.
                      </i>
                    </p>
                    <details>
                        <summary class="sum2">
                        17.3.1 The size of operator
                        </summary>
                        <p>
                          <code>sizeof</code> gives the size of an
                          object of the type.
                          <br>
                          <br>
                          For an expression it gives the size of the type
                          of the result.
                          The result of sizeof is a positive integer.
                          <br>
                          It's unit is <code>sizeof(char)</code> defined to be
                          <code>1</code>.
                          <code>sizeof(int)</code> is typically <code>4</code>.
                          <PRE>
                            <code>
void sizes(char ch, int i, int* p)
{
    cout &lt;&lt; "the size of char is " &lt;&lt; sizeof(char) &lt;&lt; ' ' &lt;&lt; sizeof (ch) &lt;&lt; '\n';
    cout &lt;&lt; "the size of int is " &lt;&lt; sizeof(int) &lt;&lt; ' ' &lt;&lt; sizeof (i) &lt;&lt; '\n';
    cout &lt;&lt; "the size of int* is " &lt;&lt; sizeof(int*) &lt;&lt; ' ' &lt;&lt; sizeof (p) &lt;&lt; '\n';
}
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Memory used by a <code>vector</code>:
                          <PRE>
                            <code>
vector&lt;int&gt; v(1000);  <span class="comment">// vector with 1000 elements of type int</span>
cout &lt;&lt; "the size of vector&lt;int&gt;(1000) is " &lt;&lt; sizeof (v) &lt;&lt; '\n';
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          <span class="hilight">Output:</span>
                          <PRE>
                            <code>
the size of vector&lt;int&gt;(1000) is 20
                            </code>
                          </PRE>
                        </p>
                    </details>

                </details>

                <details>
                    <summary class="sum1">
                    17.4 Free store and pointers
                    </summary>
                    <p>
                      The compiler sets aside memory for
                      <ul>
                        <li>
                          code (code storage or text storage)
                        </li>
                        <li>
                          global variables (static storage)
                        </li>
                        <li>
                          function calls for arguments and local variables
                          (stack storage or automatic storage)
                        </li>
                      </ul>
                    </p>
                    <p>
                      <figure>
                          <img src="graphics/Chap17Diag5.png" width="25%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      The C++ language makes this “free store”
                      (also called the heap) available
                      through an operator called <code>new</code>.
                      <PRE>
                        <code>
double* p = new double[4]; <span class="comment">// allocate 4 doubles on the free store</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      <figure>
                          <img src="graphics/Chap17Diag6.png" width="40%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      <PRE>
                        <code>
char* q = new double[4]; <span class="comment">// error: double* assigned to char*</span>
                        </code>
                      </PRE>
                    </p>
                    <p>
                      The <code>new</code> returns a pointer to a
                      <code>double</code> but a <code>double</code> isn't a
                      <code>char</code>.
                      <br>
                      It should not be assigned to the pointer to
                      <code>char</code> variable <code>q</code>.
                    </p>
                    <details>
                        <summary class="sum2">
                        17.4.1 Free-store allocation
                        </summary>
                        <p>
                          We request memory to be allocated on the free
                          store by the new operator:
                          <ul>
                            <li>
                              The new operator returns a pointer to the
                              allocated memory.
                            </li>
                            <li>
                              A pointer value is the address of the first
                              byte of the memory.
                            </li>
                            <li>
                              A pointer points to an object of a specified
                              type.
                            </li>
                            <li>
                              A pointer does not know how many elements it
                              points to.
                            </li>
                          </ul>
                        </p>
                        <br>
                        <p>
                          <span class="hilight">Example:</span>
                          <PRE>
                            <code>
int* pi = new int; <span class="comment">// allocate one int</span>
int* qi = new int[4]; <span class="comment">// allocate 4 ints (an array of 4 ints)</span>
double* pd = new double; <span class="comment">// allocate one double</span>
double* qd = new double[n]; <span class="comment">// allocate n doubles (an array of n doubles)</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          <figure>
                              <img src="graphics/Chap17Diag7.png" width="40%">
                          </figure>
                        </p>
                        <br>
                        <p>
                          Pointers to objects of different types are different
                          types.
                          <PRE>
                            <code>
pi = pd; <span class="comment">// error: can’t assign a double* to an int*</span>
pd = pi; <span class="comment">// error: can’t assign an int* to a double*</span>
                            </code>
                          </PRE>
                        </p>
                        <p>
                          Allowing assignment of pointers to different
                          types would allow type errors.
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.2 Access through pointers
                        </summary>
                        <p>
                          The subscript operator <code>[ ]</code> can also
                          be used.
                          <PRE>
                            <code>
double* p = new double[4]; <span class="comment">// allocate 4 doubles on the free store</span>
double x = *p; <span class="comment">// read the (first) object pointed to by p</span>
double y = p[2]; <span class="comment">// read the 3rd object pointed to by p</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          The <code>[ ]</code> and <code>*</code> operators can also be used for writing
                          <PRE>
                            <code>
*p = 7.7; <span class="comment">// write to the (first) object pointed to by p</span>
p[2] = 9.9; <span class="comment">// write to the 3rd object pointed to by p</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          The “contents of” operator allows to read and
                          write the object pointed to by a pointer <code>p</code>:
                          <PRE>
                            <code>
double x = *p; <span class="comment">// read the object pointed to by p</span>
*p = 8.8; <span class="comment">// write to the object pointed to by p</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          The [ ] operator treats memory as a sequence of
                          objects with the first one pointed to by a
                          pointer <code>p</code>:
                          <PRE>
                            <code>
double x = p[3]; <span class="comment">// read the 4th object pointed to by p</span>
p[3] = 4.4; <span class="comment">// write to the 4th object pointed to by p</span>
double y = p[0]; <span class="comment">// p[0] is the same as *p</span>
                            </code>
                          </PRE>
                        </p>
                        <figure>
                            <img src="graphics/Chap17Diag8.png" width="40%">
                        </figure>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.3 Ranges
                        </summary>
                        <p>
                          The pointer doesn't know how many elements it
                          points to.
                          <PRE>
                            <code>
double* pd = new double[3];
pd[2] = 2.2;
pd[4] = 4.4;
pd[–3] = –3.3;
                            </code>
                          </PRE>
                          <br>
                          <figure>
                            <img src="graphics/Chap17Diag9.png" width="40%">
                          </figure>
                        </p>
                        <br>
                        <p>
                            Using <code>vector</code> rather than using
                            memory allocated by <code>new</code> is that a
                            <code>vector</code> knows its size so that
                            out-of-range access can be prevented.
                            <br>
                            Also, we can assign one <code>double*</code> to
                            another <code>double*</code> independently of
                            how many objects each points to.
                            <PRE>
                              <code>
double* p = new double; <span class="comment">// allocate a double</span>
double* q = new double[1000]; <span class="comment">// allocate 1000 doubles</span>
q[700] = 7.7; <span class="comment">// fine</span>
q = p; <span class="comment">// let q point to the same as p</span>
double d = q[700]; <span class="comment">// out-of-range access!</span>
                              </code>
                            </PRE>
                            <br>
                            <figure>
                              <img src="graphics/Chap17Diag10.png" width="40%">
                            </figure>
                        </p>
                        <p>
                            Here, <code>q[700]</code> refers to two different
                            memory locations and the last use is an
                            out-of-range access.
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.4 Initialization
                        </summary>
                        <p>
                          <PRE>
                            <code>
double* p0; <span class="comment">// uninitialized: likely trouble</span>
double* p1 = new double; <span class="comment">// get (allocate) an uninitialized double</span>
double* p2 = new double{5.5}; <span class="comment">// get a double initialized to 5.5</span>
double* p3 = new double[5]; <span class="comment">// get (allocate) 5 uninitialized doubles</span>
                            </code>
                          </PRE>
                        </p>
                        <p>
                          It is good to ensure that pointers are initialized
                          and the object they point to are also intialized.
                          <br>
                          <br>
                          Declaring <code>p0</code> without initializing is
                          trouble.
                          <PRE>
                            <code>
*p0 = 7.0;
                            </code>
                          </PRE>
                        </p>
                        <p>
                          Here <code>7.0</code> is assigned to some
                          location in memory.
                        </p>
                        <br>
                        <p>
                          Memory allocated by new is not initialized
                          for built-in types.
                          <br>
                          An initializer list can be specified
                          for an array of objects allocated by <code>new</code>.
                          <PRE>
                            <code>
double* p4 = new double[5] {0,1,2,3,4};
double* p5 = new double[] {0,1,2,3,4};
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Also, a program with uninitialized
                          variables can run differently.
                          If a type <code>X</code> has a default constructor,
                          <PRE>
                            <code>
X* px1 = new X; <span class="comment">// one default-initialized X</span>
X* px2 = new X[17]; <span class="comment">// 17 default-initialized Xs</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Explicitly initialize if <code>Y</code> has a constructor but not a default constructor
                          <PRE>
                            <code>
Y* py1 = new Y; <span class="comment">// error: no default constructor</span>
Y* py2 = new Y{13}; <span class="comment">// OK: initialized to Y{13}</span>
Y* py3 = new Y[17]; <span class="comment">// error: no default constructor</span>
Y* py4 = new Y[17] {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
                            </code>
                          </PRE>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.5 The null pointer
                        </summary>
                        <p>
                          The value zero is called the
                          <i>null pointer</i> when assigned to a pointer.
                          <PRE>
                            <code>
if (p0 != nullptr) <span class="comment">// consider p0 valid</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          An <code>if</code>-statement really checks
                          whether its condition is <code>nullptr</code>.
                          <PRE>
                            <code>
if (p0) <span class="comment">// consider p0 valid; equivalent to p0!=nullptr</span>
                            </code>
                          </PRE>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.6 Free-store deallocation
                        </summary>
                        <p>
                          It is always a good idea to return memory to
                          the free store once it's use is finished.
                          <PRE>
                            <code>
double* calc(int res_size, int max) <span class="comment">// leaks memory</span>
{
    double* p = new double[max];
    double* res = new double[res_size];
    <span class="comment">// use p to calculate results to be put in res</span>
    return res;
}

double* r = calc(100,1000);
                            </code>
                          </PRE>
                        </p>
                        <p>
                          The call <code>calc(100,1000)</code> will render
                          the space needed for <code>1000 doubles</code>
                          unusable for the rest of the program.
                          <br>
                          <br>
                          The operator <code>delete</code> returns memory
                          to the free store.
                          <PRE>
                            <code>
double* calc(int res_size, int max)
<span class="comment">// the caller is responsible for the memory allocated for res</span>
{
    double* p = new double[max];
    double* res = new double[res_size];
    <span class="comment">// use p to calculate results to be put in res</span>
    delete[] p; <span class="comment">// we don’t need that memory anymore: free it</span>
    return res;
}

double* r = calc(100,1000);
<span class="comment">// use r</span>
delete[] r; <span class="comment">// we don’t need that memory anymore: free it</span>
                            </code>
                          </PRE>
                        </p>
                        <p>
                          The 2 forms of <code>delete</code> are:
                          <ul>
                            <li>
                              <code>delete p</code> frees the memory
                              for an individual object allocated by
                              <code>new</code>.
                            </li>
                            <li>
                              <code>delete[ ] p</code> frees the memory for
                              an array of objects allocated by
                              <code>new</code>.
                            </li>
                          </ul>
                        </p>
                        <br>
                        <p>
                          Deleting an object twice is a bad mistake.
                          <PRE>
                            <code>
int* p = new int{5};
delete p; <span class="comment">// fine: p points to an object created by new</span>
<span class="comment">// . . . no use of p here . . .</span>
delete p; <span class="comment">// error: p points to memory owned by the free-store manager</span>
                            </code>
                          </PRE>
                        </p>
                        <p>
                          The problem here is that the programmer doesn't
                          own the object anymore to delete it and it might be
                          possible that the free-store manager already
                          assigned the pointer to some another object
                          which can be mistakenly deleted.
                          <br>
                          <br>
                          Deleting null pointer is harmless.
                          <PRE>
                            <code>
int* p = nullptr;
delete p; <span class="comment">// fine: no action needed</span>
delete p; <span class="comment">// also fine (still no action needed)</span>
                            </code>
                          </PRE>
                        </p>
                    </details>

                </details>

                <details>
                    <summary class="sum1">
                    17.5 Destructors
                    </summary>
                    <p>
                      Just as the way a constructor is called when an object
                      class is created, a <code>destructor</code> is called
                      when an object goes out of scope.
                      <br>
                      It makes sure that an object is properly
                      cleaned up before it is destroyed.
                      <PRE>
                        <code>
<span class="comment">// a very simplified vector of doubles</span>
class vector {
    int sz; <span class="comment">// the size</span>
    double* elem; <span class="comment">// a pointer to the elements</span>
public:
    vector(int s) <span class="comment">// constructor</span>
          :sz{s},
          elem{new double[s]} <span class="comment">// allocate memory</span>
          {
              for (int i=0; i&lt;s; ++i)
                  elem[i]=0; <span class="comment">// initialize elements</span>
          }
          ~vector() <span class="comment">// destructor</span>
              { delete[] elem; } <span class="comment">// free memory</span>
          <span class="comment">// . . .</span>
};

void f3(int n)
{
    double* p = new double[n]; <span class="comment">// allocate n doubles</span>
    vector v(n); <span class="comment">// the vector allocates n doubles</span>
    <span class="comment">// . . . use p and v . . .</span>
    delete[ ] p; <span class="comment">// deallocate p’s doubles</span>
} <span class="comment">// vector automatically cleans up after v</span>
                        </code>
                      </PRE>
                    </p>
                    <details>
                        <summary class="sum2">
                        17.5.1 Generated destructors
                        </summary>
                        <p>
                          Destructors are called when the object is destroyed.
                          <PRE>
                            <code>
struct Customer {
    string name;
    vector&lt;string&gt; addresses;
    <span class="comment">// . . .</span>
};

void some_fct()
{
    Customer fred;
    <span class="comment">// initialize fred</span>
    <span class="comment">// use fred</span>
}
                            </code>
                          </PRE>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.5.2 Destructors and free store
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                </details>

                <details>
                    <summary class="sum1">
                    17.6 Access to elements
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    17.7 Pointers to class objects
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    17.8 Messing with types: void* and casts
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    17.9 Pointers and references
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                    <details>
                        <summary class="sum2">
                        17.9.1 Pointer and reference parameters
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.9.2 Pointers, references, and inheritance
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.9.3 An example: lists
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.9.4 List operations
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.9.5 List use
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                </details>

                <details>
                    <summary class="sum1">
                    17.10 The this pointer
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                    <details>
                        <summary class="sum2">
                        17.10.1 More link use
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                </details>


                <details>
                    <summary class="sum1">
                    Test Yourself!
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Exams_in_Jaura%2C_India.jpg/560px-Exams_in_Jaura%2C_India.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>
<!-- Include the test material here! -->
                </details>


                <details>
                    <summary class="sum1">
                    Drill
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Queens.guard.buck.palace.arp.jpg/600px-Queens.guard.buck.palace.arp.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>

                    <ol>
                    </ol>
                </details>

            </div>
        </div>

    </body>
</html>

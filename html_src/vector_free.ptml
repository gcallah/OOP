<!DOCTYPE html>
<html>
    <head>
<!--include head.txt -->
        <title>
            17. Vector and Free Store
        </title>
<!--include googleAnalyticsScript.txt -->
    </head>

    <body>
        <div class="wrapper">
<!--include navbar.txt -->
            <div id="content">
                <h1>
                    17. Vector and Free Store
                </h1>

                <p class="leadquote">
                "Use <code>vector</code> as the default."
                -- Alex Stepanov
                </p>

                <details>
                    <summary class="sum1">
                    17.1 Introduction
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a6/Vector_components_and_base_change.svg/400px-Vector_components_and_base_change.svg.png"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>

                    <p>
                        The most useful class in the standard C++ library is
                        <code>vector</code>.
                        We are going to undertake an adventure: we are going to
                        try to understand how <code>vector</code> was gradually
                        built to what we have today, why it was so designed,
                        and along the way we will gain some understanding of
                        how we might create our own container. We will also
                        gain an understanding of how computer programs work at
                        a deeper level than we have encountered before.
                    </p>

                    <p>
                        Why bother with all of these details? The reason is, if
                        we want to become true software professionals, we must
                        understand how our languages use the underlying
                        hardware!
                    </p>

                </details>

                <details>
                    <summary class="sum1">
                    17.2 vector basics
                    </summary>
                    <p>
                      <PRE>
                        <code>
vector&lt;double&gt; age(4); <span class="comment">// a vector with 4 elements of type double</span>
age[0]=0.33;
age[1]=22.0;
age[2]=27.2;
age[3]=54.2;
                        </code>
                      </PRE>
                      <br>
                      <figure>
                          <img src="graphics/Chap17Diag1.png" width="40%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      Elements of <code>age</code> are numbered
                      <code>0</code> to <code>age.size()-1</code>.
                      <br>
                      Defining a fixed-size data structure,
                      <br>
                      <PRE>
                        <code>
class vector {
int size, age0, age1, age2, age3;
// . . .
};
                        </code>
                      </PRE>
                      <br>
                      <figure>
                          <img src="graphics/Chap17Diag2.png" width="40%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      Adding an element with <code>push_back()</code> becomes
                      difficult as defined <code>vector</code> has fixed
                      number of elements.
                      <br>
                      We need a data member that points to the set of elements
                      so that it points to different set of elements
                      when more space is needed.
                      <br>
                      A <code>pointer</code> holds an address and is
                      distinguished by the suffix <code>*</code>
                      meaning "pointer to <code>double</code>".
                      <PRE>
                        <code>
<span class="comment">// a very simplified vector of doubles (like vector&lt;double&gt;)</span>
class vector {
int sz; <span class="comment">// the size</span>
double* elem; <span class="comment">// pointer to the first element (of type double)</span>
public:
vector(int s); <span class="comment">// constructor: allocate s doubles,</span>
<span class="comment">// let elem point to them</span>
<span class="comment">// store s in sz</span>
int size() const { return sz; } <span class="comment">// the current size</span>
};
                        </code>
                      </PRE>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    17.3 Memory, addresses, and pointers
                    </summary>
                    <p>
                      An <code>address</code> is a "number that
                      indicates a location in memory".
                      <br>
                      <br>
                      A megabyte of memory can be visualized as following,
                      <figure>
                          <img src="graphics/Chap17Diag3.png" width="40%">
                      </figure>
                      <br>
                      <br>
                      <PRE>
                          <code>
int var = 17;
                          </code>
                      </PRE>
                    </p>
                    <p>
                      Here, an "int-size" piece of memory for
                      var is set aside and value 17 is put in memory.
                    </p>
                    <br>
                    <p>
                      <PRE>
<code>
int* ptr = &var; <span class="comment">// ptr holds the address of var</span>
</code>
                      </PRE>
                    </p>

                    <p>
                      The type needed to hold the address of an
                      <code>int</code> is “pointer to int” or
                      an “int pointer” and the notation is <code>int*</code>.
                      <br>
                      <br>
                      The “address of” operator, unary <code>&</code>,
                      is used to get the address of an object.
                      So, if <code>var</code> happens to start at address
                      <code>4096</code>, <code>ptr</code> will hold
                      the value <code>4096</code>:
                      <figure>
                          <img src="graphics/Chap17Diag4.png" width="40%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      Each type has a corresponding pointer type.
                      <PRE>
                        <code>
int x = 17;
int* pi = &x; <span class="comment">// pointer to int</span>
double e = 2.71828;
double* pd = &e; <span class="comment">// pointer to double</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      To see value of the object pointed to,
                      <PRE>
                        <code>
cout &lt;&lt; "pi==" &lt;&lt; pi &lt;&lt; "; contents of pi==" &lt;&lt; *pi &lt;&lt; "\n";
cout &lt;&lt; "pd==" &lt;&lt; pd &lt;&lt; "; contents of pd==" &lt;&lt; *pd &lt;&lt; "\n";
                        </code>
                      </PRE>
                    </p>
                    <p>
                      The output for <code>*pi</code> will be the integer
                      <code>17</code> and the output for <code>*pd</code>
                      will be the double <code>2.71828</code>.
                      <br>
                      The output for pi and pd will vary depending on
                      where the compiler allocated our variables x and e in
                      memory.
                    </p>
                    <br>
                    <p>
                      The contents of operator can also be used on the
                      left-hand side of an assignment:
                      <PRE>
                        <code>
*pi = 27; <span class="comment">// OK: you can assign 27 to the int pointed to by pi</span>
*pd = 3.14159; <span class="comment">// OK: you can assign 3.14159 to the double pointed to by pd</span>
*pd = *pi; <span class="comment">// OK: you can assign an int (*pi) to a double (*pd)</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      <code>int</code> provides the
                      operations suitable for integers.
                      <br>
                      A pointer type provides the operations suitable
                      for addresses.
                      <PRE>
                        <code>
int i = pi; <span class="comment">// error: can’t assign an int* to an int</span>
pi = 7; <span class="comment">// error: can’t assign an int to an int*</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      Also, a pointer to <code>char</code>
                      a <code>char*</code>) is not a pointer
                      to <code>int</code> (an <code>int*</code>):
                      <PRE>
                        <code>
char* pc = pi; <span class="comment">// error: can’t assign an int* to a char*</span>
pi = pc; <span class="comment">// error: can’t assign a char* to an int*</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      Why is it an error?
                      <PRE>
                        <code>
char ch1 = 'a';
char ch2 = 'b';
char ch3 = 'c';
char ch4 = 'd';
int* pi = &ch3; <span class="comment">// point to ch3, a char-size piece of memory</span>
<span class="comment">// error: we cannot assign a char* to an int*</span>
<span class="comment">// but let’s pretend we could</span>
*pi = 12345; <span class="comment">// write to an int-size piece of memory</span>
*pi = 67890;
                        </code>
                      </PRE>
                    </p>
                    <p>
                      If the compiler would have allowed the code,
                      <code>12345</code> would be written to the memory
                      starting at <code>&ch3</code>.
                      <br>
                      Then the next assignment <code>*pi=67890</code> would
                      place <code>67890</code> in some completely
                      different part of memory.
                      <br>
                      <br>
                      <i>
                        Thats why our aim is always to work at
                        highest level of abstraction.
                      </i>
                    </p>
                    <details>
                        <summary class="sum2">
                        17.3.1 The size of operator
                        </summary>
                        <p>
                          <code>sizeof</code> gives the size of an
                          object of the type.
                          <br>
                          <br>
                          For an expression it gives the size of the type
                          of the result.
                          The result of sizeof is a positive integer.
                          <br>
                          It's unit is <code>sizeof(char)</code> defined to be
                          <code>1</code>.
                          <code>sizeof(int)</code> is typically <code>4</code>.
                          <PRE>
                            <code>
void sizes(char ch, int i, int* p)
{
cout &lt;&lt; "the size of char is " &lt;&lt; sizeof(char) &lt;&lt; ' ' &lt;&lt; sizeof (ch) &lt;&lt; '\n';
cout &lt;&lt; "the size of int is " &lt;&lt; sizeof(int) &lt;&lt; ' ' &lt;&lt; sizeof (i) &lt;&lt; '\n';
cout &lt;&lt; "the size of int* is " &lt;&lt; sizeof(int*) &lt;&lt; ' ' &lt;&lt; sizeof (p) &lt;&lt; '\n';
}
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Memory used by a <code>vector</code>:
                          <PRE>
                            <code>
vector&lt;int&gt; v(1000);  <span class="comment">// vector with 1000 elements of type int</span>
cout &lt;&lt; "the size of vector&lt;int&gt;(1000) is " &lt;&lt; sizeof (v) &lt;&lt; '\n';
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          <span class="hilight">Output:</span>
                          <PRE>
                            <code>
the size of vector&lt;int&gt;(1000) is 20
                            </code>
                          </PRE>
                        </p>
                    </details>

                </details>

                <details>
                    <summary class="sum1">
                    17.4 Free store and pointers
                    </summary>
                    <p>
                      The compiler sets aside memory for
                      <ul>
                        <li>
                          code (code storage or text storage)
                        </li>
                        <li>
                          global variables (static storage)
                        </li>
                        <li>
                          function calls for arguments and local variables
                          (stack storage or automatic storage)
                        </li>
                      </ul>
                    </p>
                    <p>
                      <figure>
                          <img src="graphics/Chap17Diag5.png" width="25%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      The C++ language makes this “free store”
                      (also called the heap) available
                      through an operator called <code>new</code>.
                      <PRE>
                        <code>
double* p = new double[4]; <span class="comment">// allocate 4 doubles on the free store</span>
                        </code>
                      </PRE>
                    </p>
                    <br>
                    <p>
                      <figure>
                          <img src="graphics/Chap17Diag6.png" width="40%">
                      </figure>
                    </p>
                    <br>
                    <p>
                      <PRE>
                        <code>
char* q = new double[4]; <span class="comment">// error: double* assigned to char*</span>
                        </code>
                      </PRE>
                    </p>
                    <p>
                      The <code>new</code> returns a pointer to a
                      <code>double</code> but a <code>double</code> isn't a
                      <code>char</code>.
                      <br>
                      It should not be assigned to the pointer to
                      <code>char</code> variable <code>q</code>.
                    </p>
                    <details>
                        <summary class="sum2">
                        17.4.1 Free-store allocation
                        </summary>
                        <p>
                          We request memory to be allocated on the free
                          store by the new operator:
                          <ul>
                            <li>
                              The new operator returns a pointer to the
                              allocated memory.
                            </li>
                            <li>
                              A pointer value is the address of the first
                              byte of the memory.
                            </li>
                            <li>
                              A pointer points to an object of a specified
                              type.
                            </li>
                            <li>
                              A pointer does not know how many elements it
                              points to.
                            </li>
                          </ul>
                        </p>
                        <br>
                        <p>
                          <span class="hilight">Example:</span>
                          <PRE>
                            <code>
int* pi = new int; <span class="comment">// allocate one int</span>
int* qi = new int[4]; <span class="comment">// allocate 4 ints (an array of 4 ints)</span>
double* pd = new double; <span class="comment">// allocate one double</span>
double* qd = new double[n]; <span class="comment">// allocate n doubles (an array of n doubles)</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          <figure>
                              <img src="graphics/Chap17Diag7.png" width="40%">
                          </figure>
                        </p>
                        <br>
                        <p>
                          Pointers to objects of different types are different
                          types.
                          <PRE>
                            <code>
pi = pd; <span class="comment">// error: can’t assign a double* to an int*</span>
pd = pi; <span class="comment">// error: can’t assign an int* to a double*</span>
                            </code>
                          </PRE>
                        </p>
                        <p>
                          Allowing assignment of pointers to different
                          types would allow type errors.
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.2 Access through pointers
                        </summary>
                        <p>
                          The subscript operator <code>[ ]</code> can also
                          be used.
                          <PRE>
                            <code>
double* p = new double[4]; <span class="comment">// allocate 4 doubles on the free store</span>
double x = *p; <span class="comment">// read the (first) object pointed to by p</span>
double y = p[2]; <span class="comment">// read the 3rd object pointed to by p</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          The <code>[ ]</code> and <code>*</code> operators can also be used for writing
                          <PRE>
                            <code>
*p = 7.7; <span class="comment">// write to the (first) object pointed to by p</span>
p[2] = 9.9; <span class="comment">// write to the 3rd object pointed to by p</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          The “contents of” operator allows to read and
                          write the object pointed to by a pointer <code>p</code>:
                          <PRE>
                            <code>
double x = *p; <span class="comment">// read the object pointed to by p</span>
*p = 8.8; <span class="comment">// write to the object pointed to by p</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          The [ ] operator treats memory as a sequence of
                          objects with the first one pointed to by a
                          pointer <code>p</code>:
                          <PRE>
                            <code>
double x = p[3]; <span class="comment">// read the 4th object pointed to by p</span>
p[3] = 4.4; <span class="comment">// write to the 4th object pointed to by p</span>
double y = p[0]; <span class="comment">// p[0] is the same as *p</span>
                            </code>
                          </PRE>
                        </p>
                        <figure>
                            <img src="graphics/Chap17Diag8.png" width="40%">
                        </figure>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.3 Ranges
                        </summary>
                        <p>
                          The pointer doesn't know how many elements it
                          points to.
                          <PRE>
                            <code>
double* pd = new double[3];
pd[2] = 2.2;
pd[4] = 4.4;
pd[–3] = –3.3;
                            </code>
                          </PRE>
                          <br>
                          <figure>
                            <img src="graphics/Chap17Diag9.png" width="40%">
                          </figure>
                        </p>
                        <br>
                        <p>
                            Using <code>vector</code> rather than using
                            memory allocated by <code>new</code> is that a
                            <code>vector</code> knows its size so that
                            out-of-range access can be prevented.
                            <br>
                            Also, we can assign one <code>double*</code> to
                            another <code>double*</code> independently of
                            how many objects each points to.
                            <PRE>
                              <code>
double* p = new double; <span class="comment">// allocate a double</span>
double* q = new double[1000]; <span class="comment">// allocate 1000 doubles</span>
q[700] = 7.7; <span class="comment">// fine</span>
q = p; <span class="comment">// let q point to the same as p</span>
double d = q[700]; <span class="comment">// out-of-range access!</span>
                              </code>
                            </PRE>
                            <br>
                            <figure>
                              <img src="graphics/Chap17Diag10.png" width="40%">
                            </figure>
                        </p>
                        <p>
                            Here, <code>q[700]</code> refers to two different
                            memory locations and the last use is an
                            out-of-range access.
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.4 Initialization
                        </summary>
                        <p>
                          <PRE>
                            <code>
double* p0; <span class="comment">// uninitialized: likely trouble</span>
double* p1 = new double; <span class="comment">// get (allocate) an uninitialized double</span>
double* p2 = new double{5.5}; <span class="comment">// get a double initialized to 5.5</span>
double* p3 = new double[5]; <span class="comment">// get (allocate) 5 uninitialized doubles</span>
                            </code>
                          </PRE>
                        </p>
                        <p>
                          It is good to ensure that pointers are initialized
                          and the object they point to are also intialized.
                          <br>
                          <br>
                          Declaring <code>p0</code> without initializing is
                          trouble.
                          <PRE>
                            <code>
*p0 = 7.0;
                            </code>
                          </PRE>
                        </p>
                        <p>
                          Here <code>7.0</code> is assigned to some
                          location in memory.
                        </p>
                        <br>
                        <p>
                          Memory allocated by new is not initialized
                          for built-in types.
                          <br>
                          An initializer list can be specified
                          for an array of objects allocated by <code>new</code>.
                          <PRE>
                            <code>
double* p4 = new double[5] {0,1,2,3,4};
double* p5 = new double[] {0,1,2,3,4};
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Also, a program with uninitialized
                          variables can run differently.
                          If a type <code>X</code> has a default constructor,
                          <PRE>
                            <code>
X* px1 = new X; <span class="comment">// one default-initialized X</span>
X* px2 = new X[17]; <span class="comment">// 17 default-initialized Xs</span>
                            </code>
                          </PRE>
                        </p>
                        <br>
                        <p>
                          Explicitly initialize if <code>Y</code> has a constructor but not a default constructor
                          <PRE>
                            <code>
Y* py1 = new Y; <span class="comment">// error: no default constructor</span>
Y* py2 = new Y{13}; <span class="comment">// OK: initialized to Y{13}</span>
Y* py3 = new Y[17]; <span class="comment">// error: no default constructor</span>
Y* py4 = new Y[17] {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
                            </code>
                          </PRE>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.5 The null pointer
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.4.6 Free-store deallocation
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                </details>

                <details>
                    <summary class="sum1">
                    17.5 Destructors
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                    <details>
                        <summary class="sum2">
                        17.5.1 Generated destructors
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.5.2 Destructors and free store
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                </details>

                <details>
                    <summary class="sum1">
                    17.6 Access to elements
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    17.7 Pointers to class objects
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    17.8 Messing with types: void* and casts
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    17.9 Pointers and references
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                    <details>
                        <summary class="sum2">
                        17.9.1 Pointer and reference parameters
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.9.2 Pointers, references, and inheritance
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.9.3 An example: lists
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.9.4 List operations
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        17.9.5 List use
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                </details>

                <details>
                    <summary class="sum1">
                    17.10 The this pointer
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                    <details>
                        <summary class="sum2">
                        17.10.1 More link use
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>

                </details>


                <details>
                    <summary class="sum1">
                    Test Yourself!
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Exams_in_Jaura%2C_India.jpg/560px-Exams_in_Jaura%2C_India.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>
<!-- Include the test material here! -->
                </details>


                <details>
                    <summary class="sum1">
                    Drill
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Queens.guard.buck.palace.arp.jpg/600px-Queens.guard.buck.palace.arp.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>

                    <ol>
                    </ol>
                </details>

            </div>
        </div>

    </body>
</html>

<!DOCTYPE html>
<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <link rel="stylesheet" href="style.css">

        <!-- jQuery CDN -->
         <script src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
         <!-- Bootstrap Js CDN -->
         <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

         <script type="text/javascript">
             var status = 'on';
             $(document).ready(function () {
                 $('#sidebarCollapse').on('click', function () {
                     $('#sidebar').toggleClass('active');
                     if (status == 'on') {
                         $('#sidebarText').text("Expand Side Nav");
                         status = 'off';
                     } else {
                         $('#sidebarText').text("Collapse Side Nav");
                         status = 'on';
                     }
                 });
             });
         </script>
        <title>
            9. Technicalities: Classes, etc.
        </title>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114841175-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-114841175-1');
</script>
    </head>

    <body>
        <div class="wrapper">
<!-- Sidebar Holder -->
<nav id="sidebar">
        <div id="sidebarCollapse">
        <div class="sidebar-header">
            <h1>
            Object-Oriented Programming
            </h1>
            <strong>OOP</strong>
        </div>
    </div>
    <ul class="list-unstyled components">
        <li>
        <a href="index.html">
        <i class="glyphicon glyphicon-home"></i>
        Home
        </a>
        </li>
        <li>
        <a href="#Submenu0" data-toggle="collapse" aria-expanded="false">
        <i class="glyphicon glyphicon-list"></i>
        Topics
        </a>
        </li>
        <ul class="collapse list-unstyled" id="Submenu0">
            <li>
            <a href="#Submenu1" data-toggle="collapse" aria-expanded="false">
            Part I: The Basics
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu1">
                <li>
                <a href="hello.html">
                2. Hello, World!
                </a>
                </li>
                <li>
                <a href="otv.html">
                3. Objects, Types, and Values
                </a>
                </li>
                <li>
                <a href="computation.html">
                4. Computation
                </a>
                </li>
                <li>
                <a href="errors.html">
                5. Errors
                </a>
                </li>
                <li>
                <a href="writing.html">
                6. Writing a Program
                </a>
                </li>
                <li>
                <a href="completing.html">
                7. Completing a Program
                </a>
                </li>
                <li>
                <a href="functions.html">
                8. Technicalities: Functions, etc.
                </a>
                </li>
                <li>
                <a href="classes.html">
                9. Technicalities: Classes, etc.
                </a>
                </li>
            </ul>
            <li>
            <a href="#Submenu2" data-toggle="collapse" aria-expanded="false">
            Part II: Input and Output
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu2">
                <li>
                <a href="iostreams.html">
                10. Input and Output Streams
                </a>
                </li>
                <li>
                <a href="customizingio.html">
                11. Customizing Input and Output
                </a>
                </li>
                <li>
                <a href="display_model.html">
                12. A Display Model
                </a>
                </li>
                <li>
                <a href="graphics_classes.html">
                13. Graphics Classes
                </a>
                </li>
                <li>
                <a href="class_design.html">
                14. Graphics Class Design
                </a>
                </li>
                <li>
                <a href="graphing_funcs.html">
                15. Graphing Functions and Data
                </a>
                </li>
                <li>
                <a href="gui.html">
                16. Graphical User Interfaces
                </a>
                </li>
            </ul>
            <li>
            <a href="#Submenu3" data-toggle="collapse" aria-expanded="false">
            Part III: Data and Algorithms
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu3">
                <li>
                <a href="vector_free.html">
                17. Vector and Free Store
                </a>
                </li>
                <li>
                <a href="vector_array.html">
                18. Vectors and Arrays
                </a>
                </li>
                <li>
                <a href="vector_templ.html">
                19. Vector, Templates, and Exceptions
                </a>
                </li>
                <li>
                <a href="containers.html">
                20. Containers and Iterators
                </a>
                </li>
                <li>
                <a href="algorithms.html">
                21. Algorithms and Maps
                </a>
                </li>
            </ul>
            <li>
            <a href="#Submenu4" data-toggle="collapse" aria-expanded="false">
            Part IV Broadening the View
            </a>
            </li>
            <ul class="collapse list-unstyled" id="Submenu4">
                <li>
                <a href="history.html">
                22. Ideals and History
                </a>
                </li>
                <li>
                <a href="text.html">
                23. Text Manipulation
                </a>
                </li>
                <li>
                <a href="numerics.html">
                24. Numerics
                </a>
                </li>
                <li>
                <a href="embedded.html">
                25. Embedded Systems Programming
                </a>
                </li>
                <li>
                <a href="testing.html">
                26. Testing
                </a>
                </li>
                <li>
                <a href="C.html">
                27. The C Programming Language
                </a>
                </li>
            </ul>
        </ul>
        <li>
        <a href="#Submenu5" data-toggle="collapse" aria-expanded="false">
        <i class="glyphicon glyphicon-blackboard"></i>
        Other Materials
        </a>
        </li>
        <ul class="collapse list-unstyled" id="Submenu5">
            <li>
            <a href="syllabi/SyllabusSu2018.html">
            <i class="glyphicon glyphicon-tasks"></i>
            Course Syllabus
            </a>
            </li>
            <li>
            <a href="https://github.com/gcallah/OOP/tree/03c8d77c5ee5faae253d8a8e989aa347af0c3c45/code">
            <i class="glyphicon glyphicon-list-alt"></i>
            Source Code
            </a>
            </li>
            <li>
            <a href="tests/midterm_key.html">
            <i class="glyphicon glyphicon-pencil"></i>
            Midterm
            </a>
            </li>
            <li>
            <a href="http://www.stroustrup.com/programming.html">
            <i class="glyphicon glyphicon-book"></i>
            Our textbook's website
            </a>
            </li>
            <li>
            <a href="C++tips.html">
            <i class="glyphicon glyphicon-hand-right"></i>
            C++ Tips
            </a>
            </li>
            <li>
            <a href="https://gcallah.github.io/utils/unix_guide.html">
            <i class="glyphicon glyphicon-hand-right"></i>
            Guide to UNIX
            </a>
            </li>
        </ul>
        <li>
        <a href="about.html">
        <i class="glyphicon glyphicon-info-sign"></i>
        About
        </a>
        </li>
    </ul>
</nav>
            <div id="content">
                <h1>
                    9. Technicalities: Classes, etc.
                </h1>
                <details>
                    <summary class="sum1">
                    9.1 User-defined types
                    </summary>
                    
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    The C++ language provides you with some built-in types,
                    such as <code>char</code>, <code>int</code>,
                    and <code>double</code>. A type is called
                    built-in if the compiler knows how to represent objects of
                    the type and which operations can be done on it (such as +
                    and *) without being told by declarations supplied by a
                    programmer in source code.
                    </p>
                    <p>
                    
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    9.2 Classes and members
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    A class is a user-defined type. It is composed of built-in
                    types, other user-defined types, and functions. The parts
                    used to define the class are called members. A class has
                    zero or more members. For example: 
                    </p>
                    
                    <p>
                    <code>
                        <pre>
class X {
    public:
        int m; // data member 
        int mf(int v) { int old = m; m=v; return old; } // function member 
};
                        </pre>
                    </code>
                    </p>

                    <p>
                    Members can be of various types. Most are either data
                    members, which define the representation of an object of
                    the class, or function members, which provide operations on
                    such objects. We access members using the
                    <code>object.member</code>
                    notation. For example:
                    </p>

                    <p>
                    <code>
                        <pre>
X var;             // var is a variable of type X
var.m = 7;         // assign to var’s data member m
int x = var.mf(9); // call var’s member function mf()
                        </pre>
                    </code>
                    </p>


                    <p>
                        You can read var.m as var’s m. Most people pronounce it
                        “var dot m” or “var’s m.” The type of a member
                        determines what operations we can do on it. We can read
                        and write an int member, call a function member, etc.
                        A member function, such as X’s mf(), does not need to
                        use the var.m notation.  It can use the plain member
                        name (m in this example). Within a member function, a
                        member name refers to the member of that name in the
                        object for which the member function was called. Thus,
                        in the call var.mf(9), the m in the definition of mf()
                        refers to var.m.  
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    9.3 Interface and implementation
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                        Usually, we think of a class as having an interface
                        plus an implementation. The interface is the part of
                        the class’s declaration that its users access directly.
                        The implementation is that part of the class’s
                        declaration that its users access only indirectly
                        through the interface. The public interface is
                        identified by the label public: and the implementation
                        by the label private:. You can think of a class
                        declaration like this:
                    </p>

                    <p>
                    <code>
                        <pre>
class X {
    // this class’s name is X
    public:
        // public members:
        //
        – the interface to users (accessible by all)
        // functions
        // types
        // data (often best kept private)
    private:
        // private members:
        //
        – the implementation details (used by members of this class only)
        // functions
        // types
        // data
};
                        </pre>
                    </code>
                    </p>


                    <p>
                        Class members are private by default.
                        <br />
                        We use private and public to represent the important
                        distinction between an interface (the user’s view of
                        the class) and implementation details (the
                        implementer’s view of the class). We explain that and
                        give lots of examples as we go along. Here we’ll just
                        mention that for something that’s just data, this
                        distinction doesn’t make sense. So, there is a useful
                        simplified notation for a class that has no private
                        implementation details.  
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    9.4 Evolving a class
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                        Let’s illustrate the language facilities supporting
                        classes and the basic techniques for using them by
                        showing how — and why — we might evolve a simple data
                        structure into a class with private implementation
                        details and supporting operations. We use the
                        apparently trivial problem of how to represent a date
                        (such as August 14, 1954) in a program. The need for
                        dates in many programs is obvious (commercial
                        transactions, weather data, calendar programs, work
                        records, inventory management, etc.).  The only
                        question is how we might represent them.
                    </p>
                    <details>
                        <summary class="sum2">
                        9.4.1 struct and functions
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                            How would we represent a date? When asked, most
                            people answer, “Well, how about the year, the
                            month, and the day of the month?” That’s not the
                            only answer and not always the best answer, but
                            it’s good enough for our uses, so that’s what we’ll
                            do. Our first attempt is a simple struct:
                        </p>

                        <p>
                        <code>
                            <pre>
// simple Date (too simple?)
struct Date {
    int y; // year
    int m; // month in year
    int d; // day of month
};
Date today; // a Date variable (a named object)
                            </pre>
                        </code>
                        </p>

                    </details>
                    <details>
                        <summary class="sum2">
                        9.4.2 Member functions and constructors
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        We provided an initialization function for
                        <code>Date</code>s, one that provided an important
                        check on the validity of <code>Date</code>s. However,
                        checking functions are of little use if we fail to use
                        them. For example, assume that we have defined the
                        output operator <code><pre>&lt;&lt;</pre></code> for a
                            <code>Date</code>.
                        </p>
                        <p>
                        <code>
                        <pre>
void f()
{
    Date today;
    // . . .
    cout &lt;&lt; today &lt;&lt; '\n';              // use today
    // . . .
    init_day(today,2008,3,30);
    // . . .
    Date tomorrow;
    tomorrow.y = today.y;
    tomorrow.m = today.m;              // add 1 to today
    tomorrow.d = today.d+1;            // use tomorrow
    cout &lt;&lt; tomorrow &lt;&lt; '\n';
}
                        </pre>
                        </code>
                        </p>
                        <p>
                        Here, we “forgot” to immediately initialize
                        today and “someone” used it before
                        we got around to calling init_day().
                        “Someone else” decided that it was a
                        waste of time to call add_day() — or maybe
                        hadn’t heard of it — and constructed
                        tomorrow by hand. As it happens, this is
                        bad code — very bad code. Sometimes,
                        probably most of the time, it works, but
                        small changes lead to serious errors.
                        </p>
                        <p>
                        This kind of thinking leads to a demand for an
                        initialization function that can’t
                        be forgotten and for operations that are less
                        likely to be overlooked. The basic
                        tool for that is member functions, that is,
                        functions declared as members of the class within
                        the class body. For example:
                   </p>
                    <code>
                    <pre>
// simple Date
// guarantee initialization with constructor
// provide some notational convenience
struct Date {
    int y, m, d;                // year, month, day
    Date(int y, int m, int d);  // check for valid date and initialize
    void add_day(int n);        // increase the Date by n days
};
                    </pre>
                    </code>
                    <p>
                    A member function with the same name as its class is
                    special. It is called a constructor and will be used for
                    initialization (“construction”) of objects of the class. It
                    is an error — caught by the compiler — to forget to
                    initialize an object of a class that has a constructor that
                    requires an argument, and there is a special convenient
                    syntax for doing such initialization:
                    </p>
                    <code>
                    <pre>
Date my_birthday;                   // error: my_birthday not initialized
Date today {12,24,2007};            // oops! run-time error
Date last {2000,12,31};             // OK (colloquial style)
Date next = {2014,2,14};            // also OK (slightly verbose)
Date christmas = Date{1976,12,24};  // also OK (verbose style)
                    </pre>
                    </code>
                    </details>
                    <details>
                        <summary class="sum2">
                        9.4.3 Keep details private
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        We still have a problem: What if someone forgets to use
                        the member function <code>add_day()</code>?
                        What if someone decides to change the month directly?
                        After all, we “forgot” to provide a facility for that:
                        </p>
                        <code>
                        <pre>
Date birthday {1960,12,31}; // December 31, 1960
++birthday.d;               // ouch! Invalid date
                            // (birthday.d==32 makes today invalid)
Date today {1970,2,3};      
today.m = 14;               // (today.m==14 makes today invalid)
                        </pre>
                        </code>
                        <p>
                        As long as we leave the representation of Date
                        accessible to everybody, somebody will — by accident or
                        design — mess it up; that is, someone will do something
                        that produces an invalid value. In this case, we
                        created a Date with a value that doesn’t correspond to
                        a day on the calendar. Such invalid objects are time
                        bombs; it is just a matter of time before someone
                        innocently uses the invalid value and gets a run-time
                        error or — usually worse — produces a bad result.
                        </p>

                        <p>
                        Such concerns lead us to conclude that the
                        representation of Date should be inaccessible to users
                        except through the public member functions that we
                        supply
                        </p>
                    </details>

                    <details>
                        <summary class="sum2">
                        9.4.4 Defining member functions
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        So far, we have looked at Date from the point of view
                        of an interface designer and a user. But sooner or
                        later, we have to implement those member functions.
                        First, here is a subset of the Date class reorganized
                        to suit the common style of providing the public
                        interface first:
                        </p>
                        <code>
                        <pre>
// simple Date (some people prefer implementation details last)
class Date {
public:
    Date(int y, int m, int d); // constructor: check for valid date and initialize
    void add_day(int n);       // increase the Date by n days
    int month();               // . . .
private:
    int y, m, d;                // year, month, day
};
                        </pre>
                        </code>
                        <p>
                        People put the public interface first because the
                        interface is what most people are interested in. In
                        principle, a user need not look at the implementation
                        details. In reality, we are typically curious and have
                        a quick look to see if the implementation looks
                        reasonable and if the implementer used some technique
                        that we could learn from.  However, unless we are the
                        implementers, we do tend to spend much more time with
                        the public interface. The compiler doesn’t care about
                        the order of class function and data members; it takes
                        the declarations in any order you care to present
                        them.
                        </p>
                        
                        <p>
                        Defining member functions outside the class
                        declaration is the preferred C++ style. It
                        makes the declaration cleaner, and reduces
                        recompilation.
                        But for small functions, the benefits of inlining
                        may help.
                        When we define a member outside its class, we need to
                        say which class it is a member of. We do that using the
                        class_name::member_name notation:
                        </p>
                        <code>
                        <pre>
Date::Date(int yy, int mm, int dd)      // constructor
:y{yy}, m{mm}, d{dd}                    // note: member initializers
{
}
void Date::add_day(int n)
{   
    // . . .
}
int month()                 // oops: we forgot Date::
{
    return m;               // not the member function, can’t access m
}
                        </pre>
                        </code>
                        <p>
                        The<code> :y{yy}, m{mm}, d{dd}</code> notation is how
                        we initialize members. It is called a (member)
                        initializer list. We could have written:
                        </p>
                        <code>
                        <pre>
Date::Date(int yy, int mm, int dd) // Constructor
{
    y = yy;
    m = mm;
    d = dd;
}
                        </pre>
                        </code>
                    </details>
                    <details>
                        <summary class="sum2">
                        9.4.5 Referring to the current object
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        Consider a simple use of the <code>Date</code> class so far:
                        </p>
                        <code>
                        <pre>
class Date {
    // . . .
    int month() { return m; }
    // . . .
private:
    int y, m, d;    // year, month, day
};
void f(Date d1, Date d2)
{
    cout &lt;&lt; d1.month() &lt;&lt; ' ' &lt;&lt; d2.month() &lt;&lt; '\n';<br/>
}
                        </pre>
                        </code>
                        <p>
                        How does<code> Date::month()</code> know to return the value of<code> d1.m </code>in the first call and
                        <code>d2.m</code> in the second? Look again at
                        <code>Date::month();</code> its declaration specifies no function argument! How does
                        <code>Date::month()</code> know for which object it was
                        called? A class member function, such as <code>Date::month()</code>, has an implicit
                        argument which it uses to identify the object for
                        which it is called. So in the first call,<code> m</code>correctly refers to <code>d1.m</code> and in the
                        second call it refers to <code>d2.m.</code>.
                        </p>
                    </details>
                    <details>
                        <summary class="sum2">
                        9.4.6 Reporting errors
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        What do we do when we find an invalid date? Where in
                        the code do we look for invalid dates? We know that the
                        answer to the first question is “Throw an exception,”
                        and the obvious place to look is where we first
                        construct a <code>Date</code>. If we don’t create
                        invalid <code>Date</code>s and also write our member
                        functions correctly, we will never have a<code>
                        Date</code> with an invalid value.  So, we’ll prevent
                    users from ever creating a<code> Date</code> with an
                    invalid state:
                        </p>
                        <code>
                        <pre>
// simple Date (prevent invalid dates)
class Date {
public:
    class Invalid { };              // to be used as exception
    Date(int y, int m, int d);      // check for valid date and initialize
// . . .
private:
    int y, m, d;                    // year, month, day
    bool is_valid();                // return true if date is valid
};
                        </pre>
                        </code>
                        <p>
                        We put the testing of validity into a separate<code>
                            is_valid()</code> function because checking for
                        validity is logically distinct from initialization and
                        because we might want to have several constructors. As
                        you can see, we can have private functions as well as
                        private data:
                        </p>
                        <code>
                        <pre>
Date::Date(int yy, int mm, int dd)
: y{yy}, m{mm}, d{dd}                   // initialize data members
{
    if (!is_valid()) throw Invalid{};   // check for validity    
}
bool Date::is_valid()                   // return true if date is valid
{
    if (m&lt;1 || 12&lt;m) return false;
    // . . .
}
                        </pre>
                        </code>
                        <p>
                        Given that definition of<code> Date</code>, we can write
                        </p>
                        <code>
                        <pre>
void f(int x, int y)
try {
    Date dxy {2004,x,y};
    cout &lt;&lt; dxy &lt;&lt; '\n';
dxy.add_day(2);
}
catch(Date::Invalid) {
    error("invalid date");
}
                        </pre>
                        </code>
                        <p>
                        We now know that &lt;&lt; and
                        <code>add_day()</code>will have a valid
                        <code>Date</code> on which to operate.  Before
                        completing the evolution of our<code> Date</code> class
                        in section 9.7, we’ll take a detour to describe a
                        couple of general language
                        facilities that we’ll need to
                        do that well: enumerations and operator overloading.
                        </p>
                    </details>   
                </details>

                <details>
                    <summary class="sum1">
                        Drill
                    </summary>

                    <p>
                        Write the date class above, along with a main that has
                        tests for valid and invalid dates.
                        Include increment methods for year, month, and day.
                        Write tests to make sure these do not give you
                        dates like 14/34/2018!
                    </p>


                </details>


                <details>
                    <summary class="sum1">
                    9.5 Enumerations
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    An <code>enum</code> (an enumeration) is a very simple
                    user-defined type, specifying its set of values (its
                    enumerators) as symbolic constants. For example:
                    </p>
                    <code>
                    <pre>
enum class Month {
    jan=1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
};
                    </pre>
                    </code>
                    <p>
                        If we don’t initialize the first enumerator, the count
                        starts with 0. For example:
                    </p>
                    <pre>
                    <code>
enum class Day {
    monday, tuesday, wednesday, thursday, friday, saturday, sunday
};
                    </code>
                    </pre>
                    <details>
                        <summary class="sum2">
                        9.5.1 "Plain" enumerations
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        In addition to the enum classes, also known as scoped
                        enumerations, there are “plain” enumerations that
                        differ from scoped enumerations by implicitly
                        “exporting” their enumerators to the scope of the
                        enumeration and allowing implicit conversions to int.
                        For example:
                        </p>

                    <code>
                    <pre>
enum Month {                   // note: no “class”
    jan=1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
};
Month m = feb;                  // OK: feb in scope
Month m2 = Month::feb;          // also OK
m = 7;                          // error: can’t assign an int to a Month
int n = m;                      // OK: we can assign a Month to an int
Month mm = Month(7);            // convert int to Month (unchecked)
                    </pre>
                    </code>
                    <p>
                    “plain” enums are less strict than enum classes.
                    </p>
                    </details>
                </details>

                <details>
                    <summary class="sum1">
                        Drill
                    </summary>

                    <p>
                        Add enums for month and day of the week to your Date
                        class.
                        Add a vector of strings that maps months from the
                        enum to words for the months.
                        Add a method <code>print_long_date</code> 
                        that prints out the month as a word not a number.
                        Think about how to add the option to print day of
                        the week.
                    </p>

                </details>

                <details>
                    <summary class="sum1">
                    9.6 Operator overloading
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    You can define almost all C++ operators for class or
                    enumeration operands. That’s often called operator
                    overloading. We use it when we want to provide conventional
                    notation for a type we design. For
                    example:
                    </p>
                    <code>
                    <pre>
enum class Month {
    Jan=1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
};
Month operator++(Month &amp; m)                  // prefix increment operator
{
    m = (m==Dec) ? Jan : Month(int(m)+1);   // “wrap around”
    return m;
}
                    </pre>
                    </code>
                    <p>
The<code> ? :</code> construct is an “arithmetic if”: <code>m</code> becomes
<code>Jan</code> if (m==Dec) and
<code>Month(int(m)+1)</code> otherwise. It is a reasonably
elegant way of expressing the fact that months “wrap around” after December.
The<code> Month</code> type can now be used like this:
                    </p>
<code>
<pre>
Month m = Sep;
++m;        // m becomes Oct
++m;        // m becomes Nov
++m;        // m becomes Dec
++m;        // m becomes Jan (“wrap around”)
</pre>
</code>
                </details>
                <details>
                    <summary class="sum1">
                    9.7 Class interfaces
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    We have argued that the public interface and the
                    implementation parts of a class should be separated. As
                    long as we leave open the possibility of using structs for
                    types that are “plain old data,” few professionals would
                    disagree. However, how do we design a good interface? What
                    distinguishes a good public interface from a mess? Part of
                    that answer can be given only by example, but there are a
                    few general principles that we can list and that are given
                    some support in C++:
                    </p>
                    <ul>
                    <li>Keep interfaces complete</li>
                    <li>Keep interfaces minimal</li>
                    <li>Provide constructors</li>
                    <li>Support copying (or prohibit it)</li>
                    <li>Use types to provide good argument checking</li>
                    <li>Identify nonmodifying member functions</li>
                    <li>Free all resources in the destructor</li>
                    </ul>
                    <details>
                        <summary class="sum2">
                        9.7.1 Argument types
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>

                        <p>
                        When we defined the constructor for Date in §9.4.3, we
                        used three ints as the arguments. That caused some
                        problems:
                        </p>

                        <code>
                        <pre>
Date d1 {4,5,2005}; // oops: year 4, day 2005
Date d2 {2005,4,5}; // April 5 or May 4?
                        </pre>
                        </code>

                        <p>
                        The first problem (an illegal day of the month) is
                        easily dealt with by a test in the constructor.
                        However, the second (a month vs. day-of-the-month
                        confusion) can’t be caught by code written by the user.
                        The second problem is simply that the conventions for
                        writing month and day-in-month differ; for example, 4/5
                        is April 5 in the United States and May 4 in England.
                        Since we can’t calculate our way out of this, we must
                        do something else. The obvious solution is to use
                        a<code> Month</code> type:
                        </p>
                        <code>
                        <pre>
enum class Month {
    jan=1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
};
// simple Date (use Month type)
class Date {
public:
    Date(int y, Month m, int d);
// . . .
private:
    int y;
    Month m;
    int d;
};
                        </pre>
                        </code>
                    </details>
                    <details>
                        <summary class="sum2">
                        9.7.2 Copying
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        We always have to create objects; that is, we must
                        always consider initialization and constructors.
                        Arguably they are the most important members of a
                        class: to write them, you have to decide what it takes
                        to initialize an object and what it means for a value
                        to be valid (what is the invariant?). Just thinking
                        about initialization will help you avoid errors.<br/>
                        The next thing to consider is often: Can we copy our
                        objects? And if so, how do we copy them?<br/> For Date
                        or Month, the answer is that we obviously want to copy
                        objects of that type and that the meaning of copy is
                        trivial: just copy all of the members. Actually, this
                        is the default case. So as long as you don’t say
                        anything else, the compiler will do exactly that. For
                        example, if you copy a Date as an initializer or
                        right-hand side of an assignment, all its members are
                        copied:
                        </p>
                        <code>
                        <pre>
Date holiday {1978, Month::jul, 4};   // initialization
Date d2 = holiday;
Date d3 = Date{1978, Month::jul, 4};
holiday = Date{1978, Month::dec, 24}; // assignment
d3 = holiday;
                        </pre>
                        </code>
                    </details>
                    <details>
                        <summary class="sum2">
                        9.7.3 Default constructors
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                    Uninitialized variables can be a serious source of errors.
                    To counter that problem, we have the notion of a
                    constructor to guarantee that every object of a class is
                    initialized. For example, we declared the constructor<code>
                    Date::Date(int,Month,int)</code> to ensure that every<code>
                    Date</code> is properly initialized. In the case of
                    <code>Date</code>, that means that the
                    programmer must supply three
                    arguments of the right types
                        </p>
                    </details>
                    <details>
                        <summary class="sum2">
                        9.7.4 const member functions
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        Some variables are meant to be changed — that’s why we
                        call them “variables” — but some are not; that is, we
                        have “variables” representing immutable values. Those,
                        we typically call constants or just consts.
                        </p>
                    </details>
                    <details>
                        <summary class="sum2">
                        9.7.5 Members and "helper functions"
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        When we design our interfaces to be minimal (though
                        complete), we have to leave out lots of operations that
                        are merely useful.  A function that can be simply,
                        elegantly, and efficiently implemented as a
                        freestanding function (that is, as a nonmember
                        function) should be implemented outside the class. That
                        way, a bug in that function cannot directly corrupt the
                        data in a class object. Not accessing the
                        representation is important because the usual debug
                        technique is “Round up the usual suspects”; that is,
                        when something goes wrong with a class, we first look
                        at the functions that directly access the
                        representation: one of those almost certainly did it.
                        If there are a dozen such functions, we will be much
                        happier than if there were 50.
                        </p>                
                                        
                        <p>
                        Helper functions are also called convenience functions,
                        auxiliary functions, and many other things. The
                        distinction between these functions and other nonmember
                        functions is logical; that is, “helper function” is a
                        design concept, not a programming language concept. The
                        helper functions often take arguments of the classes
                        that they are helpers of.
                        </p>
                    </details>
                </details>

                <details>
                    <summary class="sum1">
                    Test Yourself!
                    </summary>
                    <figure>
                        <img src="https:// upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Exams_in_Jaura%2C_India.jpg/560px-Exams_in_Jaura%2C_India.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>
        <ol class="nested">
            <li>
                What are the two parts of a class?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q1" value="a">
                variants and constants
                </li>
                <li>
                <input type="radio" name="q1" value="b">
                interface and implementation
                </li>
                <li>
                <input type="radio" name="q1" value="c">
                local and global
                </li>
                <li>
                <input type="radio" name="q1" value="d">
                interference and instantiation
                </li>
            </ol>
            <li>
                Which of the following is a class invariant for <code>Date</code>?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q2" value="a">
                we must always have a month less than 13
                </li>
                <li>
                <input type="radio" name="q2" value="b">
                month should be defined as an <code>int</code>
                </li>
                <li>
                <input type="radio" name="q2" value="c">
                printed dates should never take up more than one column in a spreadsheet
                </li>
                <li>
                <input type="radio" name="q2" value="d">
                the year cannot be a leap year
                </li>
            </ol>
            <li>
                When should the body of a function (its definition) be put in the class definition?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q3" value="a">
                when the function returns a built-in type
                </li>
                <li>
                <input type="radio" name="q3" value="b">
                when the function is only a line or two
                </li>
                <li>
                <input type="radio" name="q3" value="c">
                when the function is a very important part of the class
                </li>
                <li>
                <input type="radio" name="q3" value="d">
                when the function returns a user-defined type
                </li>
            </ol>
            <li>
                What would be a reasonable way to overload the plus (+) operator?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q4" value="a">
                to perform a hash function on some input string
                </li>
                <li>
                <input type="radio" name="q4" value="b">
                to access a website and add all of its pages to your site
                </li>
                <li>
                <input type="radio" name="q4" value="c">
                to add two complex numbers
                </li>
            </ol>
            <li>
                What does adding <code>const</code> to a member function do?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q5" value="a">
                promises that the function will not change the object
                </li>
                <li>
                <input type="radio" name="q5" value="b">
                says the function is a constructor
                </li>
                <li>
                <input type="radio" name="q5" value="c">
                asserts that the function will constantly return the same value for the same input
                </li>
            </ol>
            <li>
                A class can hold the following
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q6" value="a">
                data
                </li>
                <li>
                <input type="radio" name="q6" value="b">
                functions
                </li>
                <li>
                <input type="radio" name="q6" value="c">
                both data & functions
                </li>
                <li>
                <input type="radio" name="q6" value="d">
                none of the mentioned
                </li>
            </ol>
            <li>
                What defines the member of the class externally?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q7" value="b">
                ~
                </li>
                <li>
                <input type="radio" name="q7" value="c">
                ::
                </li>
                <li>
                <input type="radio" name="q7" value="d">
                none of the mentioned
                </li>
                <li>
                <input type="radio" name="q7" value="e">
                :
                </li>
            </ol>
            <li>
                Which of the following is an access specifier?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q8" value="a">
                All specified
                </li>
                <li>
                <input type="radio" name="q8" value="b">
                protected
                </li>
                <li>
                <input type="radio" name="q8" value="c">
                private
                </li>
                <li>
                <input type="radio" name="q8" value="d">
                public
                </li>
            </ol>
            <li>
                Which of the following access specifiers can be used for an interface?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q9" value="a">
                public
                </li>
                <li>
                <input type="radio" name="q9" value="b">
                All specified
                </li>
                <li>
                <input type="radio" name="q9" value="c">
                private
                </li>
                <li>
                <input type="radio" name="q9" value="d">
                protected
                </li>
            </ol>
            <li>
                Constructors are used to
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q10" value="a">
                initialize the objects
                </li>
                <li>
                <input type="radio" name="q10" value="b">
                construct the data members
                </li>
                <li>
                <input type="radio" name="q10" value="c">
                both initialize the objects & construct the data members
                </li>
                <li>
                <input type="radio" name="q10" value="d">
                none of the mentioned
                </li>
            </ol>
            <li>
                Which of the following is the correct way of implementing an interface A by Class B?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q11" value="a">
                class B extends A{}
                </li>
                <li>
                <input type="radio" name="q11" value="b">
                class B imports A{}
                </li>
                <li>
                <input type="radio" name="q11" value="c">
                all specified
                </li>
                <li>
                <input type="radio" name="q11" value="d">
                class B implements A{}
                </li>
            </ol>
            <li>
                Member function of a class can ..
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q12" value="a">
                Access subclass members
                </li>
                <li>
                <input type="radio" name="q12" value="b">
                Access all the members of the class
                </li>
                <li>
                <input type="radio" name="q12" value="c">
                Access only the private members of the class
                </li>
                <li>
                <input type="radio" name="q12" value="d">
                Access only Public members of the class
                </li>
            </ol>
            <li>
                Which of the following is not necessary for constructors?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q13" value="a">
                It must contain a definition body
                </li>
                <li>
                <input type="radio" name="q13" value="b">
                Its name must be same as that of class
                </li>
                <li>
                <input type="radio" name="q13" value="c">
                It must not have any return type
                </li>
                <li>
                <input type="radio" name="q13" value="d">
                It can contains arguments
                </li>
            </ol>
            <li>
                Which of the following operators cannot be overloaded?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q14" value="a">
                All mentioned
                </li>
                <li>
                <input type="radio" name="q14" value="b">
                . (Dot operator)
                </li>
                <li>
                <input type="radio" name="q14" value="c">
                ?: (Ternary Operator)
                </li>
                <li>
                <input type="radio" name="q14" value="d">
                :: (Scope resolution operator)
                </li>
            </ol>
            <li>
                Special data types defined by users is called
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q15" value="a">
                Conditional type
                </li>
                <li>
                <input type="radio" name="q15" value="b">
                Compound type
                </li>
                <li>
                <input type="radio" name="q15" value="c">
                none specified
                </li>
                <li>
                <input type="radio" name="q15" value="d">
                Enumeration type
                </li>
            </ol>
            <li>
                In C++, const qualifier can be applied to : 1. Member functions of a class; 2. Function arguments; 3. to a class data member which is declared as static; 4. Reference variables
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q16" value="a">
                all
                </li>
                <li>
                <input type="radio" name="q16" value="b">
                only 1, 3 and 4
                </li>
                <li>
                <input type="radio" name="q16" value="c">
                only 1, 2 and 3
                </li>
                <li>
                <input type="radio" name="q16" value="d">
                only 1,2 and 4
                </li>
            </ol>
        </ol>
        <details>
            <summary class="sum3">
                Answers
            </summary>
            <p>
                1. b; 2. a; 3. b; 4. c; 5. a; 6. c; 7. b; 8. a; 9. a; 10. a; 11. d; 12. b; 13. a; 14. a; 15. d; 16. a;
            </p>
        </details>
                </details>

                <details>
                    <summary class="sum1">
                    Drill
                    </summary>
                    <figure>
                        <img src="https:// upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Queens.guard.buck.palace.arp.jpg/600px-Queens.guard.buck.palace.arp.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>

                    <p>
                        Code a full date class and write a main showing its
                        complete usage. You should include:
                    </p>

                    <ol>

                        <li>
                            Exceptions for bad dates.
                        </li>

                        <li>
                            Methods to get and to increment the day, month and
                            year.
                        </li>

                        <li>
                            A month <code>enum</code> class to ensure argument 
                            order.
                        </li>

                        <li>
                            A boolean test for leapyear outside the class.
                        </li>

                        <li>
                            Operator overloading for &lt;&lt;,
                            &gt;&gt;, ==, and !=.
                        </li>

                        <li>
                            Methods for day of the week, the next weekday,
                            and a function outside the class for testing
                            date validity, that will be passed y, m and d.
                        </li>

                    </ol>
                </details>
            </div>
        </div>

    </body>
</html>
